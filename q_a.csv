question,ans1,ans2,ans3
"Since we have an exam this week, Do we still have a lab this week and the lab itself due this sunday?",You still have lab and it is the same schedule as normal.,"Is there some place that says what is covered in the exam? Like everything up to iterators (including iterators), or will we see some stuff about trees?",https://courses.engr.illinois.edu/cs225/fa2021/exams/
"Is there some place that says what is covered in the exam? Like everything up to iterators (including iterators), or will we see some stuff about trees?",https://courses.engr.illinois.edu/cs225/fa2021/exams/,And specifically https://courses.engr.illinois.edu/cs225/fa2021/exams/exam1/,ok thank you
How similar are the exams going to be to the practice exam?,how do you get the multiply by 2 and add n for this answer?,wouldn't this be 2S(n/2) + 2n?,"just n at the end, cuz theres only one merge"
how do you get the multiply by 2 and add n for this answer?,wouldn't this be 2S(n/2) + 2n?,"just n at the end, cuz theres only one merge","this was asked on Piazza as well, but are the practice exams going to be available starting tomorrow?"
wouldn't this be 2S(n/2) + 2n?,"just n at the end, cuz theres only one merge","this was asked on Piazza as well, but are the practice exams going to be available starting tomorrow?",they better be
"this was asked on Piazza as well, but are the practice exams going to be available starting tomorrow?",they better be,Can anyone point out and explain which two are correct?,I understand e is def correct
Can anyone point out and explain which two are correct?,I understand e is def correct,D,As well
What is an operator<< is for an iterator? Why would it need one?,operator<< is the output stream override. The question is asking what operators iterators **don't** implement,Ohhhh. Thanks,They are quite similar in question style and structure but not exactly in length or question balance.
"Ah, will the exam be longer?",I am afraid I don't have an answer to that I thought that Prof. Beckman had intended to get stuff out tonight but I am not sure.,The practice exams are available now until the end of the semester. Later exams will have some questions pulled from the earlier material so they will still be there for practice later.,Similar mostly the practice is just pulling from three pools where is there is more control to make sure that there is even coverage on the actual exam.
Do this question assume deleting the data does not change were elements in the array are located or are they pushed up once? I assumed it would delete 2 like in my drawing.,It is unsorted so you can swap the element to remove with either head or tail whichever lets you remove without shifting.,"Ok, that makes sense","Does ""implemented in the best possible way"" mean it has a tail? What would make this runtime O(1)? &(*head_ + sizeOfList * bytes used per type) to get last element?"
"Does ""implemented in the best possible way"" mean it has a tail? What would make this runtime O(1)? &(*head_ + sizeOfList * bytes used per type) to get last element?",The runtime would be O(1) in the case where the singly linked list is sorted in reverse order (greatest to smallest),It's an O(1) access operation because you just fetch the head.,Ok
Does time complexity refer to average case? I thought it would refer to worst case where count overflows,I think O() means average.,What does answer e mean?,Big O is not average it is just a upperbound.
What does answer e mean?,Big O is not average it is just a upperbound.,It is saying that after n operations it take O(n) time.,B is incorrect because saying **each** insert is O(n) which is incorrect. There are some inserts which are O(1) and some which are O(n).
"Wait but if Big O is an upperbound, then why is d incorrect?","It's impossible (even in the worst possible scenario) to have n O(n) operations (giving us O(n^2), because we aren't resizing the array n times.",O(n^2) is above the possible minimal upper bound for this operation. How could you have a scenario where each insert takes O(n^2) time?,"If O(n) is an upper bound, isn't O(n^2) an upper bound?"
O(n^2) is above the possible minimal upper bound for this operation. How could you have a scenario where each insert takes O(n^2) time?,"If O(n) is an upper bound, isn't O(n^2) an upper bound?","If that was the case, wouldn't that defeat the purpose of doing big O analysis here entirely?",Yeah
"If O(n) is an upper bound, isn't O(n^2) an upper bound?","If that was the case, wouldn't that defeat the purpose of doing big O analysis here entirely?",Yeah,So why is it asking us that?
"If that was the case, wouldn't that defeat the purpose of doing big O analysis here entirely?",Yeah,So why is it asking us that?,I don't follow
So why is it asking us that?,I don't follow,"It's an incorrect answer, no?",Is it? I don't know
"It's an incorrect answer, no?",Is it? I don't know,In the screenshot e) is explicitly marked as the correct answer,I'm asking why. Technically the computer thinks its correct
Is it? I don't know,In the screenshot e) is explicitly marked as the correct answer,I'm asking why. Technically the computer thinks its correct,"but can't it still be an upperbound? I thought big Theta was used to talk about a strict upper bound, so in this cause big Theta would be theta(n)"
"but can't it still be an upperbound? I thought big Theta was used to talk about a strict upper bound, so in this cause big Theta would be theta(n)",I don't think we're on the same page here. e) has nothing to do with O(n) vs O(n^2) as your per-operation upper bound.,True. Why are b and d not correct?,See this above explanation
True. Why are b and d not correct?,See this above explanation,Big theta is the tight bound of a function. I'm not sure what this has to do with Big-O here in this case but I suppose technically it's AN upperbound and they're kind of used interchangeably here,"For answer b, why can't O(n) be an upperbound for all the O(1) and O(n)?"
"For answer b, why can't O(n) be an upperbound for all the O(1) and O(n)?","Is there a list anywhere of all the terms we need to know? I took Math213 instead of CS173 and it seems like a lot of the terms are just called different things or done differently, so I don't want to miss anything",One of the things going on here is that while big-O is in math an upper bound that is not how it is used in CS really. Sometimes we are ideal in the wording of the questions. That is you could say that mergesort is O(n!) and a math prof would say fine and in a theory class someone might say ok but that is not how it it is used.,We use it more as this is the best big-O we can find.
"Is there a list anywhere of all the terms we need to know? I took Math213 instead of CS173 and it seems like a lot of the terms are just called different things or done differently, so I don't want to miss anything",One of the things going on here is that while big-O is in math an upper bound that is not how it is used in CS really. Sometimes we are ideal in the wording of the questions. That is you could say that mergesort is O(n!) and a math prof would say fine and in a theory class someone might say ok but that is not how it it is used.,We use it more as this is the best big-O we can find.,"Because the question specifies that insert is O(n) on EACH operation. Insert IS O(n) in the worst case, but it is incorrect to say that it is O(n) is on every case."
Is this problem referring to an array or stack or both or are they the same?,See this page https://courses.engr.illinois.edu/cs225/fa2021/exams/exam1/,https://courses.engr.illinois.edu/cs225/fa2021/exams/exam1/ the recomended chapters are linked.,"There's not a list of terms, but this has all of the CS173 information that you need to know"
I get why e is correct. Is b or d correct?,B is correct. See the proof which was done in class about this specific problem if you need more context as to why,what operations are iterators guaranteed to supply?,operator++ operator!= and operator*
what operations are iterators guaranteed to supply?,operator++ operator!= and operator*,👍 thanks,We have A and C being the correct answers here right?
We have A and C being the correct answers here right?,yes,Correct,"Amortized = the usual case scenario, worst case being when the whole array needs to be copied, which is O(3N)?"
"Amortized = the usual case scenario, worst case being when the whole array needs to be copied, which is O(3N)?",Amortized is still the worst case scenario.,"Even in the worst case scenario, you only have an O(n) operation happen sometimes.","so wait, what's the difference then between those two?"
"so wait, what's the difference then between those two?","Amortized is saying ""hey we have this operation which over a sequence of operations is O(1) most of the time but is very infrequently O(n)""","It's kind of like evaluating the average runtime over an entire sequence of operations, where that sequence of operations is considered one giant worst case. Even in worst case we end up in a scenario where only some of our insertions are O(n)",ok I gotchu
how do three different values get stored into i here?,"Line 1, 4, and 5",1: i is initialized with 0,4: i is set to 2
"for question 13, is none of the statements true??",i thought the runtime is O(1) for removing at the end,the question is how do you get to the end if you don't have a tail pointer?,that's kind of the logic I used for this problem
the question is how do you get to the end if you don't have a tail pointer?,that's kind of the logic I used for this problem,"yeah if you dont have a tail pointer, you need to go through the list until you get to the end. so i thought the answer would be II and IV","but the thing is since singly-linked lists can never go backwards, even if you delete the last node at the tail, you need to make the second to last element the new tail"
Wait I thought IV is correct? Why would the answer be none of the other options is correct?,I’m still confused about this answer,"i think 4 is correct, but none of the options are just 4 so youre saying none of the options are correct","none of the options refers to the choices you can pick in the answer, not to 1,2,3,4 directly"
"Why aren't all 3 statements correct?  I am confident (d) and (e) are correct because we went over that in lecture, but isn't (a) also correct?  Like this implementation is faster than the +2 resize one, but it uses more memory?","True, but lines B and D aren't going to help that",The line above B could be changed to use less memory,lmfao
Is big O in this class like big Theta I learned in MATH 213?  So like best case rather than upper bound?,Could anyone please explain this one?,lol i just used n=4 and plugged in numbers,XD
Could anyone please explain this one?,lol i just used n=4 and plugged in numbers,XD,"Big O is used to describe asymptotic upper bound, Big Ω is is used to describe asymptotic lower bound, and Big Θ is used to describe kind of the average"
"I’m confused as to how to get 16, does grow 2 or grow 3 not increment x or y?",grow1 changes the value of y and grow2 and grow3 change the values of x and y,"after grow1, x= 0, y =2. after grow2, x = 2, y = 4, and after grow3, x = 6, y = 10","i believe, anyone lmk if i messed up any of the values pls"
Why does x not change in grow1?,"because you pass it in by value, the original variable does not change unless you pass it  in as a reference or a pointer",The function grow1 returns the x+y and changes nothing then that is added to y so at that point y is 2.,bc the value is a copy?
bc the value is a copy?,Right,That makes sense,But in grow2 and grow3 you are also updating x since they are passed by pointer and then reference.
Why aren't the ones with a tail pointer O(1)?,"the doubly linked list is. for the singly linked list, we need to traverse the whole array to find the element before the tail, which is why it's O(n)",So in the case of IV it is O(1),but there is no choice with IV its own.
Whats amortized time complexity?,is it just whatever nonamortized is and then divide by n lol,If something is O(1) then it takes O(1) each time. If something amortized O(1) then if you do it n times it will be O(n)  but it does not say what will happen each time. It is different from expected since in expected O(1) running n times you expect to be O(n) but might be more or less.,"for amortized, do we assume n is large?"
"for amortized, do we assume n is large?",or do we not have to?,is it exact for any n?,For anything wrapped in big O you get to assume n is large.
or do we not have to?,is it exact for any n?,For anything wrapped in big O you get to assume n is large.,Amortized does not have to be big O. In fact in the array list implementation you don't actually need big O just amortized.
is it exact for any n?,For anything wrapped in big O you get to assume n is large.,Amortized does not have to be big O. In fact in the array list implementation you don't actually need big O just amortized.,Does tightest running time mean smallest running time
and amortized is the O with a * right?,"Roughly, it is more saying that you have to give the big O that is the closed to possible.",That is what I have used in lecture but there is no standard symbol for amortized.,If u are inserting an item into a list why is that O(1)
"not a topical question, but for the exam, we just walk into the building, swipe our icard, go to our computer, and log onto prairielearn right?",For the intents and purposes of what you're working with consider the tight bound to be the minimal (smallest possible) upper bound of your function,Here is the info on their website https://ae3.engineering.illinois.edu/grainger-exam-services/cbtf/students/policies/,Essentially. There will be proctors that will tell you what to do when you get there but the process that you described is basically how a CBTF exam works
and we don't bring anything other than our icard right?,It is a strange time and yes you should not have/need anything else.,"You can bring anything with you, but you're required to put your bag and all non-writing utensil related items away in a separate area as you're starting the exam","might be good to bring a pencil, they don't always have them in my experience"
Anybody know what lecture the index helper was in?,September 17  lecture 11,"Inspired by this question, how do I know if it is a Run-time error or a complier error?",The probably unhelpful answer is if it happens when you compile it is compile-time and if it happens when your run the program it is run time.
"Inspired by this question, how do I know if it is a Run-time error or a complier error?",The probably unhelpful answer is if it happens when you compile it is compile-time and if it happens when your run the program it is run time.,"Hopefully somewhat more helpful is that if it is an error in the use of the language syntax, types, or protections it will be compile time but if it is about the values in variables or the actual flow of execution it is run time.",What do I do if all cbtf slots are full for the exam days?
What do I do if all cbtf slots are full for the exam days?,I probably shouldn't have waited this long to make a reservation but also I did so 😬,Contact them and see what they can do.,Okay thanks
"If it's a singly linked list, how can we access elements from the end?",you start from the front and keep going until u reach the 8th to last element,and we are saying that the size of the list is much bigger than 8,the answer is A btw
if you're going through the nodes 1 by 1 wouldn't it be O(n)?,for the first case I mean,i think in this case its 1 bc 8 is small,:pika:
What's the difference between amortized running time and regular running time?,"The idea here is that when you're finding the 8th node from the front you **always **have to progress by 8 nodes until you find what you need, regardless of the size of your linked list. In other words, O(8) is always your run time. Formally, O(8) = O(1) since they're both constant terms.

In a singly linked list (meaning you can't progress backwards from a tail node), the size of your problem is scaled by the size of your list. Every single time you find the 8th node from the end, you have to traverse through n - 8 nodes since you can't start from the back, meaning that the total number of nodes you have to traverse is variable. This means that you have O(n) runtime since your runtime scales linearly by the size of your linked list.",@willyt123 see here,Thank you!
Do these tests get curved at all?,nah,consider that if you take a 0 on this exam and have all possible extra credit points and perfect on everything else you can have a 1000,In the last at least 5 year we have not had a curve on this course.
I'm pretty sure that A is correct because we went over that doubling the size of an array is the most efficient. What other option would be correct? I think it might be C but I am not entirely sure what the other option would be,👍,that makes more sense,"I'm pretty sure this is solved by unrolling, but how would that process look? I looked at the CS173 book but I'm still pretty unsure"
"I'm pretty sure this is solved by unrolling, but how would that process look? I looked at the CS173 book but I'm still pretty unsure",there was a good discussion up here https://discord.com/channels/691691696605626428/892147061712101426/892465711912456212,"Thanks, that helped a ton",Are we allowed scratch paper?
Are we allowed scratch paper?,yes,isn't this cbtf?,they have trays of paper for you to take if you want
isn't this cbtf?,they have trays of paper for you to take if you want,can someone explain this question?,"At each step, you divide the problem into two problems of half the size (= `new_n = n/2`, two `S(new_n)` calls), where the dividing and merging each take time proportional to the size of the problem (= includes an overhead of `n` every step)"
can someone explain this question?,"At each step, you divide the problem into two problems of half the size (= `new_n = n/2`, two `S(new_n)` calls), where the dividing and merging each take time proportional to the size of the problem (= includes an overhead of `n` every step)",so `2S(n/2) + n`,Can you please explain me why E is correct? Is that because the runtime of each push is O(1) and we are doing it for n times?
Can you please explain me why E is correct? Is that because the runtime of each push is O(1) and we are doing it for n times?,it is provided,"up to 2 sheets, must be destroyed/disposed of prior to leaving the CBTF",can someone explain this q?
can someone explain this q?,consider it's just an empty list,"and you just add the first and the second one, and that's basically an integer value runtime",which well would be O(2) which is basically O(1)
can someone explain this?,"I think a and b are correct, just wanna make sure","can someone explain this too, I think it should be C in which D and E are both correct",correct
uh why? is it because sticking it into a regular array would take O(1) time (To just stick it in the position and ignore if there is stuff there or not) or because you would need to move the other items which would take O(n) time and when u amortize something u drop it down a level so itd be O(1)?,"@DarthVedha you can just take whatever's in position 42 and move it to the end, then put your new thing in 42","and then now it's just the problem of inserting at the end of an array, which we went over is O(1) amortized",ah and if we r using an array we automatically know the end. Which makes sense. thanks!
How would u be able to access the 8th element from a singly linked list in O(1) time?,https://discord.com/channels/691691696605626428/892147061712101426/892564528666116116,cool thanks,"Whenever we are finding the tightest time complexity, does the left side one always need to be faster? Ex) O(1) and O(n).  Or is it possible to be O(n) and O(1)?"
"Whenever we are finding the tightest time complexity, does the left side one always need to be faster? Ex) O(1) and O(n).  Or is it possible to be O(n) and O(1)?",I think it's finding the 8th and 8th to last respectively,if you're referring to that question,i like these addresses
"if you have  tail pointer, why is deleting from the end of the list not O(1)?","also, does setting a value in an array take O(n) time? like if I know the index already, like `array[index] = x;`",shouldnt it only take O(1) time since i know the index?,"if its a singly linked list you have to iterate through the entire list in order to set the new tail so its O(n), but if its doubly, you can use the prev iterator to set the new tail so it is O(1) i think"
"also, does setting a value in an array take O(n) time? like if I know the index already, like `array[index] = x;`",shouldnt it only take O(1) time since i know the index?,"if its a singly linked list you have to iterate through the entire list in order to set the new tail so its O(n), but if its doubly, you can use the prev iterator to set the new tail so it is O(1) i think",Ohh I see
shouldnt it only take O(1) time since i know the index?,"if its a singly linked list you have to iterate through the entire list in order to set the new tail so its O(n), but if its doubly, you can use the prev iterator to set the new tail so it is O(1) i think",Ohh I see,"could someone help me understand this, i kept getting 21 as the output"
isn't O(n/2) big omega of O(n)?,I think for big O we throw out coefficients yeah nvm,how do you get O(1)?,8th element is really small so its O(8) which becomes O(1)
how do you get O(1)?,8th element is really small so its O(8) which becomes O(1),oh since it's always 8 you just plug it in,Yep
which of these two is correct?,I know a is correct but what's the other one,c,is it c?
is it c?,o,why exactly?,Think about looping once through a size of n that's just O(n)
why exactly?,Think about looping once through a size of n that's just O(n),?,It's like the question you sent before with O(8) becomes O(1) now it's going through n pushes which is O(n)
?,It's like the question you sent before with O(8) becomes O(1) now it's going through n pushes which is O(n),"the first push allocates 100, and copies an empty array of 100, but for n = 2, 3 4 until 100 it's just O(1) right?",oh it's saying the run time of all of those pushes combined is O(n)
"the first push allocates 100, and copies an empty array of 100, but for n = 2, 3 4 until 100 it's just O(1) right?",oh it's saying the run time of all of those pushes combined is O(n),even though each push is O(1),Is the practice exam on pl the only practice we have?
Is the practice exam on pl the only practice we have?,I think,Is there somewhere I can find past exams?,bruh I don't remember enough of cs 173 to do this right
Is there somewhere I can find past exams?,bruh I don't remember enough of cs 173 to do this right,Ikr ^^^,Lmao
doesn't this depend on if it is a singly or doubly linked list?,like if it's a single linked list you still need to iterate to find the previous node,and it doesn't specify,It does not you are inserting after the node that you have a pointer to
can someone explain this one?,plug in 1 and 4 for T(n) and i think only one answer works,"think that at each level we have 5 works, so we have 5 * level and we add in the 1 at the end for the base case",so we have 5*level + 1
how true to the length of the real exam is the practice exam?,also this exam is giving me WYSE flashbacks lol,I cannot confirm or deny the length but I can say it is similar,You do CS for WYSE?
You do CS for WYSE?,i think it's called academic challenge now,in highschool,https://castle.eiu.edu/academic_challenge/ this
"Just to be clear, when we have a push function that resizes array by +=100, is the amortized time complexity per insert is O(n) and when we resize array by *= 2, the amortized time complexity per insert is O(1)?",I hated English so and loved Chem and physics. Bio was literally like random Mc questions,:pensivefrog:,i kinda miss wyse tbh
will there be short answer questions on this exam?,I think the 2 correct answers are b and e but I don't understand what e means,correct answers are a and b actually,total running time from first n pushes is O(n^2)
wait why  exactly  is A correct?,"is it the idea that because you add a constant expansion to the array, you aren't reaping the benefits of O(1) amortized? now you're down to O(N) amortized when N is very large?",no im pretty sure it's because it's doing O(n^2),aka its a subtlely different problem than the vector implementation yall went over in class
"is it the idea that because you add a constant expansion to the array, you aren't reaping the benefits of O(1) amortized? now you're down to O(N) amortized when N is very large?",no im pretty sure it's because it's doing O(n^2),aka its a subtlely different problem than the vector implementation yall went over in class,Could someone explain why it's b?
Could someone explain why it's b?,and why c  is wrong,because if I have n things i want to push back,then it takes me O(n) times
how is running time different from time complexity?,i think that's the key to this question,"so it is much more likely we don't actually need to resize, therefore making all inserts O(1) instead of O(n) (where you may need to resize for arbitrary large elements)",its the same thing
right?,"don't trust me, trust the code",what do you see?,i see an if statement
what do you see?,i see an if statement,what does that if statement mean?,"if count_ + 1 == size_t, resize the array"
what does that if statement mean?,"if count_ + 1 == size_t, resize the array",well,count is like a place holder for the top of the stack
"To be clear, which one's are the correct answers?",b,https://courses.grainger.illinois.edu/cs173/fa2020/Lectures/Notes/SummationsAndRecurrencesNotes.pdf,Oof I made a couple misclicks on the exam
I'm a bit confused. how does `i` store 3 different values?,oh god this gave me flashbacks,"First i=0, i=2, and then the line *ptr = 3 changes it","gotcha, thanks!"
Does anyone know why deleting from an array is O(1)?,"Is the question breakdown from the practice test (C++ concepts, CS theory, runtimes) roughly the same as the actual test? As in each are about 1/3 of the test? Or will it be different since short answer questions are allowed on the exam?",Shouldn't we need to create a new array without the deleted element?,Note that it is unordered and you have the index to delete. Swap with end and then delete end.
"Is the question breakdown from the practice test (C++ concepts, CS theory, runtimes) roughly the same as the actual test? As in each are about 1/3 of the test? Or will it be different since short answer questions are allowed on the exam?",Shouldn't we need to create a new array without the deleted element?,Note that it is unordered and you have the index to delete. Swap with end and then delete end.,"Oh ic, and we can just subtract 1 from count to delete end, right?"
Shouldn't we need to create a new array without the deleted element?,Note that it is unordered and you have the index to delete. Swap with end and then delete end.,"Oh ic, and we can just subtract 1 from count to delete end, right?",That is correct. The storage under the hood is different from what you are using.
"Oh ic, and we can just subtract 1 from count to delete end, right?",That is correct. The storage under the hood is different from what you are using.,vars/ objects go on the heap only when using the new keyword right?,To make anything on the heap you need to use new. That said since a class can do its own memory management something like a vector can be on the stack but it will have its own space that it is managing on the heap for the actual array.
vars/ objects go on the heap only when using the new keyword right?,To make anything on the heap you need to use new. That said since a class can do its own memory management something like a vector can be on the stack but it will have its own space that it is managing on the heap for the actual array.,is this because it can be sorted greatest to least?,Either that or have a tail pointer
is this because it can be sorted greatest to least?,Either that or have a tail pointer,oh 🤦 I assumed it only had a head for some reason,"I know we usually use getters to access private member variables, but would putting Complex::x.re_  and Complex:: x.im_ work too?"
"I know we usually use getters to access private member variables, but would putting Complex::x.re_  and Complex:: x.im_ work too?",No it would not. Private means it has to be accessed from inside the class.,we can only access them if we are given a getter,You can only access them inside a member function. That function can provide access but that is a design choice.
"this is a compiler error because `main()` has no `return 0` line, right?",No,return 1; is fine,oh wait line 17 accesses private variables
Are the 2 correct answers B and D?,Is there a difference when it is ordered?,i think its a and b but i could be wrong,"How close is the practice exam to the actual exam? Like if I keep getting 100s on the practice exam, would I be sufficiently okay then for the test?"
Is there a difference when it is ordered?,i think its a and b but i could be wrong,"How close is the practice exam to the actual exam? Like if I keep getting 100s on the practice exam, would I be sufficiently okay then for the test?","yeah, I think so"
"How close is the practice exam to the actual exam? Like if I keep getting 100s on the practice exam, would I be sufficiently okay then for the test?","yeah, I think so",D is definitely right because there's a different instance of the question without B and D is the right answer for that,I personally felt that the practice exam was significantly easier than the actual one
whats a cut edge?,an edge where if you cut it the graph is no longer connected,oh okay thank you!,why cant we do c.thickfrosting_ = true?
why cant we do c.thickfrosting_ = true?,because isnt it a var of the class Cake?,its private so you can't explicitly declare it i think,oh okay
because isnt it a var of the class Cake?,its private so you can't explicitly declare it i think,oh okay,do we need to know about bipartite graphs
bipart-what?,LOL,okay guess not,Are there any videos going over the practice exam?
Are there any videos going over the practice exam?,don't think so,can someone explain why the answer is A,I'm surprised how little review material we are given
Yeh it would’ve been nice to have a bit more of an in depth explanation of the answers but ig we can scroll through here?,does anyone wanna meet up in the eceb and go over stuff,Really? I vaguely remember hearing that it basically covers all of it and more thoroughly. Was that for another class?,that's what I've heard from other people
Really? I vaguely remember hearing that it basically covers all of it and more thoroughly. Was that for another class?,that's what I've heard from other people,@ShadySocks when is your exam?,For example full/complete trees weren't covered in the practice exam but are on the list of things to know
@ShadySocks when is your exam?,For example full/complete trees weren't covered in the practice exam but are on the list of things to know,mines at 8 today,oof
@ShadySocks are you at eceb right now?,I'm open to studying,Lmao yup definitely didn’t expect to have to do cs173 stuff when we didn’t really talk about it. But hopefully that’s just this test,wow
why can it not be a singly linked list with head and tail pointers?,I'm heading over now,To eceb @blep,I’m at grainger
you guys have room for one more?,ye,ok which classroom are u near,we aren't in a classroom
can someone explain this?,Amortised is total time divided by n,Or like defined as the average time per element,"If n>>8, insert back would be close to inserting by going through the entire list hence O(n)"
does tightest runtime mean best case?,yes i believe so,"For this question, the correct statements are a and c right?? Then what would be the correct amortized time per insert ???",yes
"For this question, the correct statements are a and c right?? Then what would be the correct amortized time per insert ???",yes,i  think o(1),But i thought + method has run time of o(n^2) for n inserts
"why does the stipulation ""n is a power of two"" not seem to affect the final answer?","i would assume i'd have to work in a log or some exponent, but i guess not",O(1) i think?,Could u explain how u got o(1)😭
O(1) i think?,Could u explain how u got o(1)😭,im not exactly sure,but i think it's cause its O(n)
and it's amoritized so O(n)/n = 1?,smth liike that,for which operation,For resizing an array by doing += 100
Then it would be O(n) as it stated in the lecture i guess?,someone called me during the exam and i noticed it only after it was ringing for a while. the call caused my zoom on my phone to pause. should i send an email to explain my situation if needed?,i took the exam online,i think for this case it was just a red herring since not saying it technically implies the answer isn't log based and that gets rid of a lot of answer choices
someone called me during the exam and i noticed it only after it was ringing for a while. the call caused my zoom on my phone to pause. should i send an email to explain my situation if needed?,i took the exam online,i think for this case it was just a red herring since not saying it technically implies the answer isn't log based and that gets rid of a lot of answer choices,if all of these creates to stack then what does creating to the heap look like?
if all of these creates to stack then what does creating to the heap look like?,the keyword new,new,cube is on stack
"if line 2 was Cube (asteriek) ptr = new Cube (asteriek), then line 2 would be in heap?",you mean,`Cube* ptr = new Cube()`?,"yes, and you would have two cube objects"
`Cube* ptr = new Cube()`?,"yes, and you would have two cube objects",i am not sure what you mean by asterick for the left hand side,* or star or asterisk
`Cube* ptr = new Cube*`?,@Hanforallckskyslikcaprifest you can surround pieces of code with 2 backticks (ie. `) and it will make look cool,`int a = 0;`,ahh
btw did u get ur question answered?,or does it not make sense?,yea,awesome sauce
or does it not make sense?,yea,awesome sauce,thx now i know if something is created to heap or stack
Wait so in main if we return 1 the program will still work perfectly fine?,yup,Could someone explain this problem to me 😓,"Not to sure about it myself tbh but
https://discord.com/channels/691691696605626428/892147061712101426/892260442569842718"
I believe it should be e and d?,Why would editing line A be more efficient,Is it just cause if you have a lot of things in the list you don’t have to worry about making more lists?,He goes over it in Sep 20 lecture
Is it just cause if you have a lot of things in the list you don’t have to worry about making more lists?,He goes over it in Sep 20 lecture,basically if you *2 size instead it gets faster,In the example in class it's +2 instead of +100 but I think it's the same gist. O(n^2) for the +2 and O(n) for the *2 implementation
they are connected well to themselves? or i dunno,i think it's just definition,odd but cool okay,ty
something like that probably?,not vacously true actually,so yes by def i think ur correct,"i said vacuously true because it could be that there is no edge, so it's its own connected component because the antecedent is false"
"The topics of templates, inheritance and polymophism are not included in the exam?",Wait sorry am I like misreading something? Why would the answer be none of the above?,The topics https://courses.engr.illinois.edu/cs225/fa2021/exams/exam1/,The issue is IV is fine but you will note that IV is never alone. In a singly-linked list you can not remove from the end in O(1) time since you can not find the node before the last node.
Wait sorry am I like misreading something? Why would the answer be none of the above?,The topics https://courses.engr.illinois.edu/cs225/fa2021/exams/exam1/,The issue is IV is fine but you will note that IV is never alone. In a singly-linked list you can not remove from the end in O(1) time since you can not find the node before the last node.,So the reason why its none of the above is just because there isn't just an individual answer for IV?
So the reason why its none of the above is just because there isn't just an individual answer for IV?,yep,That has just caused me unbelievable amounts of paranoia now,"when does x, y change values accordingly?    I got math wrong"
"when does x, y change values accordingly?    I got math wrong",I think x only changes when you pass in a pointer or a reference,"yes, I did my math wrong. it is indeed x + y= 10+6 = 16",does anyone have a good mnemonic for memorizing the order of big o runtimes
What I'm thinking is that what if n exceeds the size_ of the array?,Wouldn't that make A wrong?,Or does A statement just mean that there exist a n such that the total runtime of the first n pushes to the stack is O(n),can someone explain which one is not stored in i?:thunk:
Wouldn't that make A wrong?,Or does A statement just mean that there exist a n such that the total runtime of the first n pushes to the stack is O(n),can someone explain which one is not stored in i?:thunk:,"line 1 stores 0 in i, line 4 stores 2 in i, and line 5 stores 3 in i"
can someone explain which one is not stored in i?:thunk:,"line 1 stores 0 in i, line 4 stores 2 in i, and line 5 stores 3 in i",so line6-8 is only modifying j not i  right?,yeah
so line6-8 is only modifying j not i  right?,yeah,would 34 be a neighbor of 37?,or would it only be 36
would 34 be a neighbor of 37?,or would it only be 36,wikipedia says,cool
Do you guys think the practice exam helped prep you for the test?,my roommates said it did somewhat I think,"just wondering, the copy constructor will be invoked when pass by value right?",i dont get why we cant delete the rear
"just wondering, the copy constructor will be invoked when pass by value right?",i dont get why we cant delete the rear,Singly linked,"if we have a tail pointer, can we can easily get that value and delete it"
then whats the point of the tail pointer?,bc the second to last pointer's gotta b set to null,tail pointer gives u the data at the tail basically,yeah
"in this one, why does indexing take O(n) time?",If it's sorted could also have O(1) for finding largest and smallest if you have head and tail,is that just how indexing work?,I think it's bc you have to copy over?
is that just how indexing work?,I think it's bc you have to copy over?,copy t?,Because you'll have to make it larger since it's the first n?
I think it's bc you have to copy over?,copy t?,Because you'll have to make it larger since it's the first n?,Everything from 1 arrat to the other
copy t?,Because you'll have to make it larger since it's the first n?,Everything from 1 arrat to the other,wait what does it mean by first n pushes?
Because you'll have to make it larger since it's the first n?,Everything from 1 arrat to the other,wait what does it mean by first n pushes?,for some reason i thought it was before `count_ + 1` is `size_`
wait what does it mean by first n pushes?,for some reason i thought it was before `count_ + 1` is `size_`,i thought * needs to be implemented,correct answer is b
what really? I thought * is needed,thats what i have written in my notes lol,https://discord.com/channels/691691696605626428/691757315853910056/892586353911529502,"yeah  iterators are guaranteed to have operator++, operator!=, and operator* implemented"
does the exam include week 6?,"its only till week 5, im assuming, right?",ohh it says except,can anyone explain what d means?
"its only till week 5, im assuming, right?",ohh it says except,can anyone explain what d means?,"idk, not sure what ""first n pushes"" means"
can anyone explain what d means?,"idk, not sure what ""first n pushes"" means",like idk if it satisfies the if statement or not,isn't it just saying the big o of the for loop is O(n)
how do you know its going to the for loop?,it may or may not depending on the initial size of the array. but the worst case is that it resizes (any number of times),"oh yeah, we always assume worst case",right?
right?,"so let's say the last push causes all n elements to get copied over, then there is O(n) work",line 4 is the optimization for this implementation where the capacity is doubling every time the capacity is reached,i get that this is O(1) since we always index the same value
but dont we need to move the value that was at index 42 down?,therefore moving everything after?,also what is amortized?,in that one the array isn't sorted
therefore moving everything after?,also what is amortized?,in that one the array isn't sorted,yeah but that doesnt matter
also what is amortized?,in that one the array isn't sorted,yeah but that doesnt matter,you can swap the element at index 42 to the end and insert the element into index 42 for O(1)
do arrays have access to the end?,"if you keep track of the number of elements in the array, yes",but doesnt accessing the last element of an array take O(n) time?,since you go through the array n times
but doesnt accessing the last element of an array take O(n) time?,since you go through the array n times,to reach the last element,arrays can be accessed by index in constant time
"for this one, the two right ones are a and c right?",but im not so sure what you you can change on line B to and D to make it more memory efficient,i think it is a and e,oh
so what is amortized?,like best case?,so a is the case where you reach the for loop for an insert,"and amortized is simplifying, sort of like the average runtime of an insert"
like best case?,so a is the case where you reach the for loop for an insert,"and amortized is simplifying, sort of like the average runtime of an insert","so this implementation uses the doubling capacity you guys talked about in class, which means each insert is O(1) amortized"
is the tightest O(1) because `afterItem` could be the first element?,"i think if you have a pointer to afterItem, you would be able to link the pointers, like afterItem->next_ = newItem","just finished
man i made some dumb mistakes",how about pass by ptr and pass by ref
howd you do compared to the practice tests?,just my 3 cents but if you are comfortable with the practice test there is probably not too much to worry about on the real exam,"I couldn't figure out how to get the time complexity for this
I spent too long on it
I think it was something like this?",you got me real confused for a sec
"I couldn't figure out how to get the time complexity for this
I spent too long on it
I think it was something like this?",you got me real confused for a sec,x>>=1 sometimes can be slower than x/=2 depending on compiler optimizations,thanks but I don't think that was my problem with this one lol
"For people who don't get it  you can look at. 
https://www.youtube.com/watch?v=094y1Z2wpJg",what is the complexity required to actually get darkmode prairielearn,that looks so much nicer,there's a settings wheel on the left corner
"Does anyone know why the image on the left is not a complete tree? Except for the last level, it is perfect and all the leaves are as far left as possible. I thought this would make it a complete tree?",I think it is trying to say not that it is not complete but it does not match the one rule but does match the other.,Since it is unclear I have removed it.,Thank you for the clarification
"How big is the question pool for the practice exam? Wanted to do some before my exam, but the majority of questions I get are the same for every instance",between 10 and 15 for each of the three sections.,"Sounds good, thank you for the follow up",W
will just going through fleck's book be enough for the math foundational questions?,Will exam be curved?,I believe they haven't in the past few years so I imagine they wouldn't curve this semester unless the averages are horrible or something.,If you understand everything in the chapters from Prof. Fleck's book you will be fine.
Will exam be curved?,I believe they haven't in the past few years so I imagine they wouldn't curve this semester unless the averages are horrible or something.,If you understand everything in the chapters from Prof. Fleck's book you will be fine.,It has not been in the past and there is nothing about how grades have been make me think this would be any different.
Is the midterm stats out?,damn did like everyone get a C?,we need some 173,i'm just wondering will the later exams be cumulative?
damn did like everyone get a C?,we need some 173,i'm just wondering will the later exams be cumulative?,so like will exam 2 test on some topics from exam1
i'm just wondering will the later exams be cumulative?,so like will exam 2 test on some topics from exam1,Yes. Exam 2 covers material in Exam 1 and Exam 3 covers material in both prior exams,"Exam 3 should have more material from Exam 2 than Exam 1, that being said"
will we be able to see exam 1 and go over what we got wrong?,You can in office hours review the exam with them.,The Exam 2 is two weeks later?,"It will be Tue, Oct 26  - Thu, Oct 28"
The Exam 2 is two weeks later?,"It will be Tue, Oct 26  - Thu, Oct 28",And Exam 3 is during the week right before fall break?,after
And Exam 3 is during the week right before fall break?,after,"Tue, Nov 30    Thu, Dec 2","Cool, thank you!"
what topics will  exam 2 covered?,The info on it and a practice exam will go up tomorrow but everything through today is covered.,thank you @gcevans !,"Also, where can I find a syllabus of all of the cs 225 topics?"
"Also, where can I find a syllabus of all of the cs 225 topics?",You can look at past semesters but it is in some what a moving target.,Interesting.,Thanks again.
"Does ""need not be a BST"" mean can't be a BST in this case?",Can anyone explain why this is the answer,It means that the binary tree can be either a BST or not a BST,I got it wrong the first time and guessed that for the second
So are we not meant to assume it would be an avl bst?,e) is the answer because it's impossible to traverse to 401 in a BST,This is saying that you should consider any arbitrary binary tree,i.e. that binary tree can be a BST or not
"A little late on the reply, but why can't we traverse to 401 in a BST? I might've missed it in a lecture.",Think that each node on the list is going down the tree so think about what you have to hit.,"If your tree falls under the criteria of being a BST, that means that 401 should be in the right subtree of the node 399. If you need more context for why this is true, I would highly recommend you draw out a BST as you traverse",Oh I think that makes sense
will exam 2 only have 12 questions like the practice tests?,is anyone else getting 504 gateway timeout on prairelearn right now,Not rn but my wifi was acting up a couple minutes ago,So maybe give it a min or 2?
So maybe give it a min or 2?,i was getting it about 20mins ago,A tale of two practice tests.,Did I learn anything?
Did I learn anything?,Did I just get easier questions?,Find out when I take the test and probably get like a B or something idk,that's what the POTDs are for
Did I just get easier questions?,Find out when I take the test and probably get like a B or something idk,that's what the POTDs are for,and to make up for everything else I've messed up
"Out of curiosity, how large is the pool?",It depends on how you count it. There are some questions that are randomized inside the question so how you count that would matter. Also there were some minor changes that made essentially duplicate questions.,Oh gotcha,BST not AVL
Adding 15 would be 13's right child. Wouldn't this require a left rotation first and then a right?,"because 17, 13, and 15 would form this shape","you're right that 17,13,15 will form this shape, but after adding 15, node 11 is the first node that's imbalanced, while node 17 is still balanced.","in this case the balance factor of 11 is 2, the balance factor of 17 is -1"
"Ah that makes perfect sense, but which node would get rotated right? I'm having trouble drawing it out","Would 21 be the blue node, 11 the green, and 17 purple?",Ah I think I got it; 11 would be blue,for this one right will be the 2 childs and then finally a left rotation so that purple is root
"Would 21 be the blue node, 11 the green, and 17 purple?",Ah I think I got it; 11 would be blue,for this one right will be the 2 childs and then finally a left rotation so that purple is root,"I think a good way of thinking about this is you want to resolve ""kinks"" and you are trying to straighten them and then move them where you need to"
was it supposed to be blanks 4 and 2?,just to make sure - hashing and BTrees aren't on this exam?,Both aren't,think so
just to make sure - hashing and BTrees aren't on this exam?,Both aren't,think so,That is correct hashing and Btrees are not on the exam.
"I feel like for this it's just none of the answers are right, is there a way to conclusively prove that the order traversals don't give a unique solution?",Draw two trees that match the traversals given but produce two different traversals.,o,"is there a more mathmatical proof for ""given two order traversals, a unique corresponding tree exists""?"
"is there a more mathmatical proof for ""given two order traversals, a unique corresponding tree exists""?",A counter example is a very fine mathematical proof. In fact since it is nice a clean it is when possible one of the preferred forms. I think what you are really asking is what is an algorithm for finding one which at a high level is find the constraints from each traversal due to the recursion and see if you have constrained you to a single tree.,For example what can you say is true of the first element of a preorder traversal?,"yeah you're right I meant algorithm, sorry"
For example what can you say is true of the first element of a preorder traversal?,"yeah you're right I meant algorithm, sorry",the first element must be the root,for preorder
I was able to determine that the tree started with 3 and had a child of 1 so I knew the level order had to start with 3 then 1. Is there a way to get the whole tree from this information? How would you get that information?,could someone explain this? I tried looking at what was said on Piazza but I am still confused,r here being the range of the subtree at each step.,Let me get this right.
could someone explain this? I tried looking at what was said on Piazza but I am still confused,r here being the range of the subtree at each step.,Let me get this right.,This is much easier to do on paper but here goes.
"can we assume that the nodes are being inserted in alphabetical order, or is it something else?",The tree is a binary search tree not just any tree. This is using the insert algorithm for a BST we saw in lecture and the basis of what happens in AVL other than rotations. So you can draw the tree.,I got it now. Thanks,"if the tree has height 7, then doesn't that mean the left subtree can have at max 64 nodes because it has to be balanced? the actual answer was 127 but i don't see why that works"
"if the tree has height 7, then doesn't that mean the left subtree can have at max 64 nodes because it has to be balanced? the actual answer was 127 but i don't see why that works",\Sum_{k=0}^6 2^k so you get 127,"another way of thinking about it:
we saw 381, then 278, which means we have to be in 381's left subtree. but then we see 401, which can't be in 381's left subtree, so we know something wrong happened.","Hi, could you explain your method for that problem? I was also unsure about it"
"Hi, could you explain your method for that problem? I was also unsure about it",I know based on the pre order the root is 3 and that the first element is 1 and by process of elimination determine that a is the right answer. But I was wondering if there’s a more consistent way,I can’t find the signup for the online exam. Does anyone know where it is?,jk it’s prairie test
I can’t find the signup for the online exam. Does anyone know where it is?,jk it’s prairie test,"For those of you who are confused about the question where you are given traversals and must come up with another traversal from info given, I wrote up a very good explanation here:
https://piazza.com/class/ksnsfb757l92km?cid=1044",is there a formula for these types of questions? or more so how should I be going about this
"For those of you who are confused about the question where you are given traversals and must come up with another traversal from info given, I wrote up a very good explanation here:
https://piazza.com/class/ksnsfb757l92km?cid=1044",is there a formula for these types of questions? or more so how should I be going about this,Yes if you review the proof you can find it.,Doesn't 33 also cause a single left rotation (rotates the 25-30-35 stick)?
is there a formula for these types of questions? or more so how should I be going about this,Yes if you review the proof you can find it.,Doesn't 33 also cause a single left rotation (rotates the 25-30-35 stick)?,n(h - 1) + 1 + n(h-2)
Doesn't 33 also cause a single left rotation (rotates the 25-30-35 stick)?,n(h - 1) + 1 + n(h-2),"n(0) = 1, n(1) = 2, n(2) = 4",That looks correct to me. Could you please comment on the question in PL so we can verify what happened in the question.
can someone walk me through each insertion and the rebalances especially? i'm having trouble visualizing the rotates even after drawing it out on a whiteboard,(i guessed the right answer btw lol),"will do, thanks!","more specifically, i get that after inserting 20, you're gonna want to rotate left, but for the inserting 13 and 11 i'm kinda lost there, if anyone could help"
Could I put 7 instead of 5?,"yes, IOP and IOS both work",Gotcha!,Can't you fix the tree with only a left rotation for 26?
Can't you fix the tree with only a left rotation for 26?,that tree u drew isn't a valid AVL tree (27 to the right of 30?),no u need a number > 35,"Why? Arent inserting 33 and say 37 the exact same thing functionally, since they change the heights of the exact same nodes?"
that tree u drew isn't a valid AVL tree (27 to the right of 30?),no u need a number > 35,"Why? Arent inserting 33 and say 37 the exact same thing functionally, since they change the heights of the exact same nodes?","33 is a Right Left, 37 is just a Left"
"Why? Arent inserting 33 and say 37 the exact same thing functionally, since they change the heights of the exact same nodes?","33 is a Right Left, 37 is just a Left",Right?,Right left centered on 25 or 30?
Right?,Right left centered on 25 or 30?,"Well ok 30 isn’t unbalanced so it must be 25, but just a left fixes it, no need for right left?",Why do we need a queue for a level order traversal?
Right left centered on 25 or 30?,"Well ok 30 isn’t unbalanced so it must be 25, but just a left fixes it, no need for right left?",Why do we need a queue for a level order traversal?,A level order traversal can be performed using BFS
"Well ok 30 isn’t unbalanced so it must be 25, but just a left fixes it, no need for right left?",Why do we need a queue for a level order traversal?,A level order traversal can be performed using BFS,And ideally for BFS a queue would be the best underlying data structure
Why do we need a queue for a level order traversal?,A level order traversal can be performed using BFS,And ideally for BFS a queue would be the best underlying data structure,Because you’d be visiting the points you add first earlier
Is there a general procedure for these types of problems? I can't seem to make out the tree when drawing it that would satisfy both of the traversals. Any tips for this?,would this be the right way to build a bst with a sequence like this? Or am i thinking about this the wrong way,3 and 8 aren't in the right spots,should look like this i think
would this be the right way to build a bst with a sequence like this? Or am i thinking about this the wrong way,3 and 8 aren't in the right spots,should look like this i think,ah ok thanks
Is a perfect binary tree also complete?,yes,"For a complete binary tree of height 4, would levels 1, 2, 3, and 4 be filled in and the 5th level would have as many left as possible?",yes
"For a complete binary tree of height 4, would levels 1, 2, 3, and 4 be filled in and the 5th level would have as many left as possible?",yes,how would u know how to build an avl tree from a traversal they give?,Every insertion you rotate the tree to make sure its balanced accordingly
how would u know how to build an avl tree from a traversal they give?,Every insertion you rotate the tree to make sure its balanced accordingly,i dont get how to insert into the avl tree,do we start with the left child or the right
there's a post on piazza https://piazza.com/class/ksnsfb757l92km?cid=1044 that might help,traversal or insert?,doesn't matter? you start at root. then if < go left and > go right,i forgot what u do with = but ig it depends on ur implementation
traversal or insert?,doesn't matter? you start at root. then if < go left and > go right,i forgot what u do with = but ig it depends on ur implementation,for the exam i dont think u will need to build a tree with =
doesn't matter? you start at root. then if < go left and > go right,i forgot what u do with = but ig it depends on ur implementation,for the exam i dont think u will need to build a tree with =,traversal
"it asks ""Which of the following sequences of keys cannot be the inOrder traversal of an AVL tree?""",Well an AVL tree is a BST so what needs to be true of the inOrder traversal?,is the output supposed to be in sorted order?,"Yes, that will be true of any BST right the BST property will ensure that is true."
Well an AVL tree is a BST so what needs to be true of the inOrder traversal?,is the output supposed to be in sorted order?,"Yes, that will be true of any BST right the BST property will ensure that is true.",is there a specific lecture where these properties are discussed?
is the output supposed to be in sorted order?,"Yes, that will be true of any BST right the BST property will ensure that is true.",is there a specific lecture where these properties are discussed?,When we talked about BST and when we talked about traversals and in lab_trees.
is there a specific lecture where these properties are discussed?,When we talked about BST and when we talked about traversals and in lab_trees.,are the lab handouts available anywhere to look at?,they should be on the top right corner of the individual lab pages
are the lab handouts available anywhere to look at?,they should be on the top right corner of the individual lab pages,oh,thanks
"i dont understand how to get the answer for this one, do u take the number of nodes+1?","you can put all 357 keys in a line, in which case all keys have 1 NULL ptr, except for the last node which has 2 NULL ptrs","if you choose to break the line and attach it somewhere else, you take out a NULL ptr but then you introduce another NULL ptr",induction noises
"Does anyone understand how to do this? I would think that since we are deleting a leaf, no particular node is unbalanced with a value of 2, so a rotation would not even happen to begin with","if we delete 1, then 2 becomes unbalanced",since right height - left height = 1 - (-1) = 2,"then we have this shape , so we do RL
\\
/"
how do you do this?,for this one i think in order to a left rotation you need a stick where everything is going to the right,"we have 2 spots like that, at 19 and 35",theres no number in the answers greater than 35 so we chose 20
so you just choose for a left it has to go on the right and for a right it has to go on the left?,yeah,Remember the number also has to unbalance the tree,im going off of this
9 and 15 are also on the right why dont you do those?,i did it and got the right answer but i think my method is incorrect,They don’t unbalance the tree so they don’t cause a rotation,@kingcobra121 you have to choose a number that would form a 3 node long stick that points right
so it would become 19 at the top and 20 on the right and 17 and 13 on the left after the left rotation?,that would balance it?,oh actually are you performing the left rotation on node labelled 11,so that would balance everything I just did it
that would balance it?,oh actually are you performing the left rotation on node labelled 11,so that would balance everything I just did it,if you perform it on 11
anybody know in what lecture we cover this?,i think that's knowledge over multiple lectures,honestly i'd just google it,Anyone have an idea on how I'd even get started on this?
Anyone have an idea on how I'd even get started on this?,Can I assume the tree is balanced?,No,The best approach I have found is to just start drawing and see if you find something that works
Can I assume the tree is balanced?,No,The best approach I have found is to just start drawing and see if you find something that works,how would i go about for this one
https://piazza.com/class/ksnsfb757l92km?cid=1044,you left rotate on 11 and the right rotate on 17,can someoneexplain why this is b?,"that's what i was wondering, i don't think i drew my tree right"
can someoneexplain why this is b?,"that's what i was wondering, i don't think i drew my tree right",i found the lecture that the chart is in its in the lecture from oct 13,can we swap to a different exam time 1 hr before the exam?
can we swap to a different exam time 1 hr before the exam?,I think i need more time to study for this exam,do more practice test,^^
is there a formula for the minimum number of nodes in a avl tree of height h?,yeah isnt it like n(h-1) + 1 + n(h-2),Ok i swapped to tomorrow,"where n(0) = 1, n(1) = 2, n(2) = 4"
wait so is the answer node d or b?,The answer’s c.) the node containing b,so what is the last node to get added to the queue?,Ya
so what is the last node to get added to the queue?,Ya,ok i got node d,is the last one to be added
is that correct?,The last one to be added is node b,im confused on how u would get that,when i tried making the tree i got that the left side was unbalanced so i balanced it
Does anyone know which lecture had the level order traversal in it?,what do u need to know about it?,i couldnt really find it,wait nvm found it
what do u need to know about it?,i couldnt really find it,wait nvm found it,"Couldnt u get the front of the queue without dequeueing, enqueue its children, and then dequeue?"
"Couldnt u get the front of the queue without dequeueing, enqueue its children, and then dequeue?",only for stl yes,"but for an actual queue, no",a real queue by the definition we had in lecture doesn't support peeking
@Liseiden did u already take the midterm?,yeh,Oh so we use stack for DFS and any BFS we use a queue?,Just so I know i'm understanding it correctly
Oh so we use stack for DFS and any BFS we use a queue?,Just so I know i'm understanding it correctly,yeah. The difference in traversals comes from when you print out and when you're pushing the children onto the stack,"i believe in lecture we went over those using recursion, which actually is just using a stack"
"For a question like this, how do you determine which node should replace the deleted node??",successor or predecessor,Choose either IOS or IOP^,"so right -> as far left as possible
or left -> as far right as possible"
link?,https://piazza.com/class/ksnsfb757l92km?cid=1044,@Ibraheemus,ty
https://piazza.com/class/ksnsfb757l92km?cid=1044,@Ibraheemus,ty,how would i do this question
Is the answer 358?,yeah,"oh okay. There was a proof we did in class that said, if there are n data items in our representation of a binary tree, then there are n+1 nullptrs",the keys are the data I believe
Can someone explain why the answer is 15 please?,"height 3 = root + 3 levels down
so then we have 1 + 2 + 4 + 8 = 15
perfect tree = all levels filled",so that's both the min and max,a perfect binary tree is one in which every node has at least 2 children and no leaf has more depth than its adjacent leaf
"Just to make sure, this is O(n log n) because we have to traverse the height of the tree (log n operation) to insert the node and then we do that n times?",can someone explain why this is the correct answer?,You can draw a rough sketch of the tree using the preorder traversal they give you,and the info
can someone explain why this is the correct answer?,You can draw a rough sketch of the tree using the preorder traversal they give you,and the info,one sec
but do you get how I made this tree at least?,I could walk though it,"please do if possible, I tried to sketch it out but I did it incorrectly","Since it's a preorder traversal, I know the root node is going to be an asterix"
can someone explain how to calculate this?,N(h) = N(h-1) + N(h-2) + 1 where N(2)=4 N(1)=2 N(0)=1,hey just wanted to make sure I'm on the right track,That question corresponds to this BST correct?
That question corresponds to this BST correct?,looks right,I thought the height of this tree wouldbe 4 tho,why
So why is it 3?,root is 0,unless ur root node doesn't count as height?,theres 3 edges from root to leaf
unless ur root node doesn't count as height?,theres 3 edges from root to leaf,ahh ok,The number of edges is the height
would h = 5?,no?,why would it be 5,it says height 6
no?,why would it be 5,it says height 6,because its asking for left subtree
"it asks the maximum number of nodes, so basically every level should be filled?",ohhh,yeah thats right,i gave equation for minimum
Can anyone explain this? I'm still confused,"its this, where h = 5  @KurtP",Ohhhhh,ok thx
can someone explain why D is right?,root = null,Can i binary tree have 0 nodes?,oh
Can i binary tree have 0 nodes?,oh,yes,root doesn't count as a node then?
root doesn't count as a node then?,or are u saying in the case of root = null then the binary tree would have 0 nodes,it would just be an empty tree,this
"and also, an empty tree still counts as a binary tree?",yes,and an empty tree is when root = null correct?,yup
and an empty tree is when root = null correct?,yup,sweet thnx for the clarification,Can someone explain why this is b?
Can someone explain why this is b?,Im having trouble making the tree,wait  how did you know which side to insert them? Is a on the left of e because thats how it is in the alphabet?,yup
wait  how did you know which side to insert them? Is a on the left of e because thats how it is in the alphabet?,yup,is BST,so < > are valid
how is this 20? i am getting 28?,i am using 1+N(h-1)+N(h-2),Do you know what the order of the enqueue and dequeues would be?,would anyone be able to explain how to identify the imbalance after inserting here?
Do you know what the order of the enqueue and dequeues would be?,would anyone be able to explain how to identify the imbalance after inserting here?,"N(h) = N(h-1) + N(h-2) + 1 where N(2)=4 N(1)=2 N(0)=1
h = 5 because minimum and left subtree",you dequeue an node after queueing its children for a level order
would anyone be able to explain how to identify the imbalance after inserting here?,"N(h) = N(h-1) + N(h-2) + 1 where N(2)=4 N(1)=2 N(0)=1
h = 5 because minimum and left subtree",you dequeue an node after queueing its children for a level order,Look at 25 after inserting 26
oh so 1 - 3 in this case?,yup,could someone walk me through this?,"N(h) = N(h-1) + N(h-2) + 1 where N(2)=4 N(1)=2 N(0)=1
h = 5 because minimum and left subtree"
could someone walk me through this?,"N(h) = N(h-1) + N(h-2) + 1 where N(2)=4 N(1)=2 N(0)=1
h = 5 because minimum and left subtree",I do that,"minimum implies imbalance not in its favor, so h--, and since its a left subtree of the root h-- again"
and i get 28?,oh so its h of 5?,yup,"for this question what does ""enqueued"" mean?"
oh so its h of 5?,yup,"for this question what does ""enqueued"" mean?",I drew out the tree but I don't understand what they're asking for
"for this question what does ""enqueued"" mean?",I drew out the tree but I don't understand what they're asking for,i see ty!,you would use a queue to traverse
So you're queue of nodes is just the sequence of letters that they give you correct?,"Like the queue is e, a, j, i, b, d, c, g, h, f. So you're saying that when you're dequeueing your taking letters out the front of the queue",So the last node to be dequeued before j is i?,"this isn't a queue, it's a bunch of inserts for a BST"
So the last node to be dequeued before j is i?,"this isn't a queue, it's a bunch of inserts for a BST","so you would use this sequence to draw your tree, according to the order of the alphabet, with e being root","you'd then have to think of what the level order traversal would look like 
the queue is in the traversal storing the nodes"
does anyone have a better explanation?,"Ok, I think I kinda get it, so I would first put my root node ""e"" into my queue, then pop that and put my two children into the queue ""a"" and ""j"", cuz that's the next level. But after that, how do I know whether I'm going to pop ""a"" or ""j"" first?","Since a queue is first in first out, I'm not sure what the order or me putting in the children nodes would be",Would I insert children nodes into the queue from left to right or right to left?
"Ok, I think I kinda get it, so I would first put my root node ""e"" into my queue, then pop that and put my two children into the queue ""a"" and ""j"", cuz that's the next level. But after that, how do I know whether I'm going to pop ""a"" or ""j"" first?","Since a queue is first in first out, I'm not sure what the order or me putting in the children nodes would be",Would I insert children nodes into the queue from left to right or right to left?,"in order goes lowest height, then left to right"
Would I insert children nodes into the queue from left to right or right to left?,"in order goes lowest height, then left to right","pop e, so []","queue e's children, left then right, so [a, j]"
"for the height of a tree, from eric's picture, is it 4?",yup,ty,"then pop a,  so [j]
queue a's children, so [j , b]
etc"
does the exam 2 practice also cover exam 1 questions that can return?,the exams are cumulative?,yes,Why does the bst tree have a runtime of h for find while avl has log n?
the exams are cumulative?,yes,Why does the bst tree have a runtime of h for find while avl has log n?,The practice doesn’t
Why does the bst tree have a runtime of h for find while avl has log n?,The practice doesn’t,what if root is 0 and you just happened to add all the integers from 1 to n in order,But the exam itself does
could someone explain why this is the right answer?,"One way to think about it is that they both have a runtime of h. Only that a binary tree and BST has no guarantees for the height of the tree, and hence h = n worst case.","However since an AVL is self balancing, h = log n at the worst case",Hence your O(log n)
Does an avl tree have any properties other than inorder traversal is sorted and and h=log n that we need to know?,ohhhh okay that helps a lot thank you!,Well most of the intricacies come from how you get it to h=log n ie the rotations,Well other than those lol
would someone be able to explain how to construct this tree?,Minimum nodes for an AVL TREE is N(h) = N(h-1) + N(h-2) + 1 where N(0) = 1 and N(1) = 2,It’s impossible to create an unambiguous tree from these traversals,@mui there's an explanation for a similar problem on piazza but i still dont get how to do it
so having the pre and post doesn't really give us a specific tree?,In this case it’s because the list consists of so many elements of the same value,You can’t really tell when a subtree ends and you’re back in the main tree or otherwise,In general yes pre and post cannot guarantee a 100% unambiguous representation of a tree
@justin if each node was different how would u solve the problem?,But usually you can get a pretty good idea of what it should look like,"We know pre is NLR, post is LRN",First in pre must equal last in post
can someone explain in general how to know when to do a left/right/LR/RL rotation? like in terms of the inbalance,"balance < -1, and:
1. left balance < -1 then right
2. left balance > 1 then left right

balance > 1, and:
1. right balance > 1 then left
2. right balance < -1 then right left","visually, if it's a stick like this, it's either L or R","if it's an elbow like this, RL or LR, where you pull it straight into a stick, then bring it into a /\ shape"
Balance is Lheight - Rheight or the other way?,rh - lh,thank you so much!!,LR and RL is if the balance difference is -2 or 2
why would inserting 33 cause a single left rotation?,It’d be the left subchild of 35,Which would look like this tree right here,"And since we don’t care about the green nodes, looking at just the stick, we can see we need a left rotation"
"can someone explain this question, is there a formula for this or smthn?","Min for AVL :
Min(h) = Min(h-1) + Min(h-2) + 1; Min(1) = 2, Min(0) = 1",Max of a sub root of an AVL tree is max of an AVL tree of height h-1,and then plug into that formula above (the max one)
the min and max are different formulas tho?,yes,whats the min # of nodes for binary?,"wait I still don't really understand the formula, what is Min(h-1) for example"
whats the min # of nodes for binary?,"wait I still don't really understand the formula, what is Min(h-1) for example",it's a recursive function,Like is it just the minimum number of nodes  if you have height 1 is 2 nodes?
Like is it just the minimum number of nodes  if you have height 1 is 2 nodes?,cuz u have the root node and whatever other child node?,"so 
Min(5) = Min(4) + Min(3) + 1
Min(4) = Min(3) + Min(2) +1
.....
Min(1) = 2
Min(0) = 1",wait so you would just keep adding until you get to 0?
cuz u have the root node and whatever other child node?,"so 
Min(5) = Min(4) + Min(3) + 1
Min(4) = Min(3) + Min(2) +1
.....
Min(1) = 2
Min(0) = 1",wait so you would just keep adding until you get to 0?,like Min(5) = Min(4) + Min(3) + Min(2) + Min(1) + Min(0) + 1?
wait so you would just keep adding until you get to 0?,like Min(5) = Min(4) + Min(3) + Min(2) + Min(1) + Min(0) + 1?,like that would be it all the way through?,"keep going till you hit those lat two and start plugging the numbers you get back into the equation

so 

Min(3) = Min(2) + Min(1) + 1
Min(2) = Min(1) + Min(0) + 1
Min(1) = 2
Min(0) = 1"
like Min(5) = Min(4) + Min(3) + Min(2) + Min(1) + Min(0) + 1?,like that would be it all the way through?,"keep going till you hit those lat two and start plugging the numbers you get back into the equation

so 

Min(3) = Min(2) + Min(1) + 1
Min(2) = Min(1) + Min(0) + 1
Min(1) = 2
Min(0) = 1",not exactly
like that would be it all the way through?,"keep going till you hit those lat two and start plugging the numbers you get back into the equation

so 

Min(3) = Min(2) + Min(1) + 1
Min(2) = Min(1) + Min(0) + 1
Min(1) = 2
Min(0) = 1",not exactly,oh no I see what ur doing
wait did i fuck something up?,i used 2^(h+1) - 1,oh wait,yeah
so it would be (2^8) -1?,"no, 2^(6+1) - 1",wait so (2^7) -1,ye
"If i remove 8, the original root node is gone is it not?",Or is my tree constructued incorrect,Is it d?,just guessing
Is it d?,just guessing,If the tree is correct it should be d,Because that would be your IOP
is iop/ios different when the node being removed isn't the root? i'm not sure why 1 is replaced with 2,it's one child remove so the child takes it's parent place,ahhhh ty,can someone help me out with this?
can someone help me out with this?,It's not even that I don't understand preorder,like,how do I build this tree
What makes something greater or less than?,in order is just left root right,gotta build the tree first,so *'s left node would be +
"Sigh I'm so confused, I scrolled up and stuff and saw that I'm supposed to enqueue my e first, then pop, then enqueue a and j, then pop both, but ig the answer is we last enqueued B? Prolly not the right thought process.",You build the tree first,Then traverse,The tree is not in the same order as the insert
thoughts?,for this one ^,K this says I dequeue a node after queueing it's children idk anymore,It says - can only have a right child but otherwise correct
"oooh I seeee, I thought b/c of the answer it would only make sense for 3 to be on the right but I wasn't sure why, cause if that rule wasn't there then 3 could be on the left or right correct?",I did it on paper and checked it using a visualizer,Yes it would be ambiguous,Ah thank you!
"to do this, would I have to calculate the min # of nodes for a height of 4?",Yes,so that would be min(4) = min(3) + min(2) + 1,and min(3) = min(2) + min(1) + 1
so wouldn't min(4) = 12?,Can anyone explain why this is the case?,could someone explain how to rebalance this? like which node replaces which?,how is this balanced
Can anyone explain why this is the case?,could someone explain how to rebalance this? like which node replaces which?,how is this balanced,oh wait nvm i'm dumb
could someone explain how to rebalance this? like which node replaces which?,how is this balanced,oh wait nvm i'm dumb,Left rotate on 0007
why is it O(n) and not O(logn)?,You have to go through every node to delete it,Like a traversal,Not enough time for it to be more than constant
But does that time taken to remove one specific node change significantly if we were removing a node from a tree of 1000000000 elements?,And plus if you just recursively delete nodes from the bottom up it’s just simply a delete call which is O(1),Without having to rebalance or anything since we’re deleting the whole tree anyway,how to do you calculate this?
how to do you calculate this?,never mind got it!,"wait when talking about ""a tree of height x""",is the root node at height x - 1?
is the root node at height x - 1?,since the leaf node is at height 0 and so on,nvm it looks like the height of the tree is the height of the root node,so a height of x has x + 1 levels and a height of 0 is just one node
"is ""level h"" counting downwards from the top?",ok I got a 35% we can only go up from here,What is the definition of a complete binary tree?,"this is how I think about it, kinda informal tho:

A Binary Tree is a Complete Binary Tree if all the levels are completely filled except possibly the last level, and the last level has all nodes as left as possible"
What is the definition of a complete binary tree?,"this is how I think about it, kinda informal tho:

A Binary Tree is a Complete Binary Tree if all the levels are completely filled except possibly the last level, and the last level has all nodes as left as possible",So we basically count heights with the root node as 0?,If anyone can explain this I would greatly appreciate it.
So we basically count heights with the root node as 0?,If anyone can explain this I would greatly appreciate it.,Would it be just like this?,Please do @ me in the morning if you how to approach these.
Would it be just like this?,Please do @ me in the morning if you how to approach these.,yeah I think it would just be that,"ur right for both, we proved the second one in lecture"
"I get that the operation takes O(1) time, but doesn't finding the place to do the operation take more than O(1) time?",it's just concerned with the right left rotation,there's no find involved,"hmmm, okay"
is that all that will be covered?,"ex data structure student here, but was wondering what would be the amortized time complexity if we only increase the size of an array by 1.5? i thought that since it’s a multiplying factor and not a constant addition then it would still be O(n)",how would you think about this,"draw out a tree based on the information given and use the properties of a preorder traversal. (what does the first letter represent, what does the second letter represent?)"
"ex data structure student here, but was wondering what would be the amortized time complexity if we only increase the size of an array by 1.5? i thought that since it’s a multiplying factor and not a constant addition then it would still be O(n)",how would you think about this,"draw out a tree based on the information given and use the properties of a preorder traversal. (what does the first letter represent, what does the second letter represent?)",would someone be able to explain how to do this one?
"draw out a tree based on the information given and use the properties of a preorder traversal. (what does the first letter represent, what does the second letter represent?)",would someone be able to explain how to do this one?,"Looks at the next value in the list. In c, since 9 < 121, if every other node is less than 121, the node is valid. 9 < 107, so every other node in the list must be greater than 9 in the list, but 4 appears later on, so it can't be valid. @mui","Is the time to insert n nodes for an avl tree n*log n because to insert a single node its log n, so u multiply log n by n?"
would someone be able to explain how to do this one?,"Looks at the next value in the list. In c, since 9 < 121, if every other node is less than 121, the node is valid. 9 < 107, so every other node in the list must be greater than 9 in the list, but 4 appears later on, so it can't be valid. @mui","Is the time to insert n nodes for an avl tree n*log n because to insert a single node its log n, so u multiply log n by n?",could someone explain this? i tried using the recursive formula but alas
"Is the time to insert n nodes for an avl tree n*log n because to insert a single node its log n, so u multiply log n by n?",could someone explain this? i tried using the recursive formula but alas,"Height of -1: 0
Height of 0: 1
Height of 1: 1+1+0=2
Height of 2: 1+2+1=4
Height of 3: 1+4+2=7",Since we only want the left subtree we stop there
could someone explain this? i tried using the recursive formula but alas,"Height of -1: 0
Height of 0: 1
Height of 1: 1+1+0=2
Height of 2: 1+2+1=4
Height of 3: 1+4+2=7",Since we only want the left subtree we stop there,(For the full tree the answer 12 would be correct tho)
how would we know when to stop the recursion?,"Can anyone explain to me why the answer is e and not d? Options b and c seem very similar to option e, with 8 numbers with distinct values listed in increasing order. The only thing that's changing is the magnitude of the values. How can e be an invalid traversal if a and c are valid?",205 comes before 200 in e,ohhhh...I've been staring at this too long
"Can anyone explain to me why the answer is e and not d? Options b and c seem very similar to option e, with 8 numbers with distinct values listed in increasing order. The only thing that's changing is the magnitude of the values. How can e be an invalid traversal if a and c are valid?",205 comes before 200 in e,ohhhh...I've been staring at this too long,thank you
so for a height of 7 you can just stop at 5 since left could have 5 and right could have 6?,yeah i think so if its asking for the min # of nodes in a subtree,yay! i think i got it tysm,"I  got N(5) = 1 + 7 + 4 =  12, but the answer is 20. I noticed that 20 is for when h = 6. I don't understand why its 20, when the height is 5 in the problem"
"oh so the height of the root is 0?And the number of levels is h+1, right?","leaf nodes are level 0, the height of the tree is the height of the root node from 0",well,you can count it in reverse
this look correct for the tree for the quesiton above?,looks good to me,yeah except u put 3 twice,i put 3 twice?
i put 3 twice?,lol your 1 looks like a 3,oh lol,"also, what would the rotation be like for this question? if any1 knows"
"also, what would the rotation be like for this question? if any1 knows","that's just a BST, not an AVL, so there's no rotation",u just replace 6 with 5 or 7 and then make sure everything looks right,you'd swap 6 with the IOP/IOS and delete it
"But since inorder traversal is left, root, right wouldn't that mean the numbers right before/after 6 are 4 or 8 in this case?",So 4 or 8 would be the new root node?,"when traversing 4, you get (stuff from left subtree) / 4 / 5",after that you get 6
So 4 or 8 would be the new root node?,"when traversing 4, you get (stuff from left subtree) / 4 / 5",after that you get 6,so 5 is the IOP
Does it matter whether or not you swap with the IOP or IOS?,"you end up with different results, but both are valid BSTs",ok thank you sounds good!,"I believe for this one, the first blank is log(17) for the max height? And I am not sure how to find the number of nodes on level h"
"I believe for this one, the first blank is log(17) for the max height? And I am not sure how to find the number of nodes on level h",I was just on that question,"Yea I think none of them are right, because you would have to have a log",The first blank would be 4
is that not the correct equation?,and I think there's 2 on level h?,whats you're reasoning for coming to that conclusion,tbh for these I just draw them out
and I think there's 2 on level h?,whats you're reasoning for coming to that conclusion,tbh for these I just draw them out,oh ok
I understand the first part of the question but what does this part mean?,is that just the last level?,yeah,I drew out the tree
is that just the last level?,yeah,I drew out the tree,So that last row of extras would be 2 nodes?
So that last row of extras would be 2 nodes?,yeah that's how I did it,ok,Man there has to be some sort of equation for this
is my avl tree correct?,I think I'm missing something here,I think you'd rotate after inserting 8?,You have to balance the tree every time there is an imbalance after inserting
I think you'd rotate after inserting 8?,You have to balance the tree every time there is an imbalance after inserting,oh shoot yea I forgot about the rotations,and then again after inserting 1 but that shouldn't matter for this question I think
so how would i rebalance this?,just an LL rotation?,7 would need a right left,So right on 9 left on 7
just an LL rotation?,7 would need a right left,So right on 9 left on 7,Basically first 8 goes to 9s place and 9 goes right child of 8
Wait so that means memory and stuff is fair game still right? Bc ngl that kinda tripped me up last time,"Then a left rotation on 7 makes 8 the new place of 7, 7 to the left of 8 and 9 to the right of 8",Am I allowed to say the type of question or is that supposed to be a surprise?,I mean ig it would be fair game since they're cumulative and got some on test 1
Am I allowed to say the type of question or is that supposed to be a surprise?,I mean ig it would be fair game since they're cumulative and got some on test 1,The questions from exam 1 are worth 3 points instead of 5,And the test goes by faster than a practice test
Anybody figure out a good way to remember Preorder vs postorder? I think I'm fine with inorder and levelorder but the other two eh,"preorder = parent before children (pre)
postorder = parent after children (post)",and it's left child before right child in literally every traversal,wait isn't it the opposite?
wait isn't it the opposite?,Or is geeksforgeeks lying to me lol,wait,im stupid
What are the running times for the various rotations of an AVL tree?,I think they're all constant time,^,Okay what
So immediate children?,Cancel that,I'm being dumb again,@PieGe what was the correct answer?
@PieGe what was the correct answer?,I think it should be 9,yup,Can anyone explain to me why it cannot be uniquely determined?
Can anyone explain to me why it cannot be uniquely determined?,"i'm not 100% sure but my thought is that it's because it's not a bst, so we don't have any idea what's the child of what, and there are a lot of duplicates",could someone explain how to solve for this question?? a is the correct answer here but i rly dont get what we r supposed to be doing,"I think it's bc of 401, since it's a BST it should have been to the right of 399"
could someone explain how to solve for this question?? a is the correct answer here but i rly dont get what we r supposed to be doing,"I think it's bc of 401, since it's a BST it should have been to the right of 399",i think we need to draw out each bst and ensure that the order would go like that,i thought we just hv to make sure that left<root and right>root for bst
"how would we go about solving questions like these? i'm trying to draw out the trees and i can't see how the one i selected makes sense but it feels like a guessing game, so i've gotta be doing something wrong",and then everything after 399 should be less than 399 but greater than 2,ahh got it thank u,was it all are valid?
was it all are valid?,all are valid yeah,I think for BST and therefore AVL an inOrder traversal will print them out in increasing order,"bc you're starting out at the leftmost point, going to it's root, then the right subtree and recursing up"
so they just have to be increasing?,"Yeah, least to greatest",ah okay,thanks
is it none because no matter what you add the tree is still balanced?,I think so,"why is this 16? Since it is a complete binary tree, it has 2^k nodes until h-1, and then we can have one more node which is pushed to the left in level h...?","if not balanced then none of those cause a left rotation
33 keeps it balanced, 15 causes an LR if i remember correctly, 20 causes a right rotation i think, 5 also causes a right rotation"
"why is this 16? Since it is a complete binary tree, it has 2^k nodes until h-1, and then we can have one more node which is pushed to the left in level h...?","if not balanced then none of those cause a left rotation
33 keeps it balanced, 15 causes an LR if i remember correctly, 20 causes a right rotation i think, 5 also causes a right rotation","@silvery_g root has 1, 2nd level has 2, 3rd level has 4, 4th level has 8, 5th level has 1",this adds up to 16
"isn't 20 also a valid answer? it leads to the same structure as 5, doesn't it?",what would be imbalanced?,"if you add node 20, node 30 becomes imbalanced i think","20 is < 21, left subtree, not right"
what would be imbalanced?,"if you add node 20, node 30 becomes imbalanced i think","20 is < 21, left subtree, not right",OH
but then wouldn't you have to rearrange everything else?,"not really, those pointers stay attached to their nodes",you only change a few,"Yeah, the everything else is straight forward after you set 7 the root, 5 the root->left and 8 the root->right"
is this just asking how many leaves are on a BST? and is it n + 1? i don't know the proof,how are they gonna ask us to prove something in multiple choice,but anyways,the proof is in lecture 15 @Lexapedia (렉시)
could someone draw this out? i got 15 when i drew it out,rip i got 15 too,Answer should be 16. Consider the first 3 levels as being a perfect tree so you've got 2^(3+1) - 1 = 15 nodes,And 1 node in the 4th level makes 16 nodes
Are btrees on this exam?,https://courses.engr.illinois.edu/cs225/fa2021/exams/exam2/,Will a binary tree with preorder and postorder like this exist?,several will which is in fact the problem.
Will a binary tree with preorder and postorder like this exist?,several will which is in fact the problem.,Could you give me one simply using `1 1 2` as the pre-order and post-order?,Ah I get it
Could you give me one simply using `1 1 2` as the pre-order and post-order?,Ah I get it,nvm,thank you
"here is my AVL tree for this problem, I think I made a mistake does everything look right?",That is not a legal AVL tree since both 6 and 9 are out of balance.,oh shoot,sorry brain fart lol
does anyone remember why the answer to this is 3?,i goes 0 (line 1) -> 2 (line 4) -> 4 (line 5),thank you!,does anyone know how to do this?
does anyone know how to do this?,@mm-is-here at what time did u post the problem?,Well I agree with you about the root of the tree but clearly 1 has to be one of the children of the root since it is the 2nd in the preorder. Similarly 10 has to be one of the children since it is 2nd to last in the post order. You then work on from that.,"why would adding 9 cause a single left rotation here?? wouldnt it be added to the left of 35, which would then be bent and cause a complex rotation?"
@mm-is-here at what time did u post the problem?,Well I agree with you about the root of the tree but clearly 1 has to be one of the children of the root since it is the 2nd in the preorder. Similarly 10 has to be one of the children since it is 2nd to last in the post order. You then work on from that.,"why would adding 9 cause a single left rotation here?? wouldnt it be added to the left of 35, which would then be bent and cause a complex rotation?",Why do you think adding 9 would cause a single left rotation?
"why would adding 9 cause a single left rotation here?? wouldnt it be added to the left of 35, which would then be bent and cause a complex rotation?",Why do you think adding 9 would cause a single left rotation?,Also why do you think it would go to the left of 35.,Sorry i meant adding 33
Why do you think adding 9 would cause a single left rotation?,Also why do you think it would go to the left of 35.,Sorry i meant adding 33,"3:46 PM, why?"
"3:46 PM, why?","ohh, okay, i see",thanks,Ok so when you add 33 it will be left of 35 but 35 is still in balance. Looking at 30 it is also still in balance since the left is 0 and the right is one. The first node out of balance is 25 which needs a single left to fix it.
"Ahh got it. Also, is the reason why 25 need a single left is bc 25,30,35 are straight??",Right. You can also look it as the balance all being out of balance in the same way as per the algorithm from lecture.,Okok. Thank u!!,if anyone is down to do review ill be at grainger until my exam
would this be a max height of 4 and 2 nodes on level h?,yeah i think so,What imbalances would cause a RL rotation and a LR rotation?,"RL is when the imbalance is right heavy and that node's right child is left heavy I think
And LR is the opposite"
What imbalances would cause a RL rotation and a LR rotation?,"RL is when the imbalance is right heavy and that node's right child is left heavy I think
And LR is the opposite",Can somebody explain how the answer is A with a diagram ?,"I kept getting 4, 5, 8, 7, 6"
Can somebody explain how the answer is A with a diagram ?,"I kept getting 4, 5, 8, 7, 6",Are you making sure to make an AVL?,this is what i got for the AVL
Are you making sure to make an AVL?,this is what i got for the AVL,you should rotate after inserting 6 and 8 so,same
but isn’t that unbalanced?,which node?,5,It has a balance of 1 which is < 2
which node?,5,It has a balance of 1 which is < 2,if we're doing R(height) - L(height)
"im probs overthinking this a little but for the questions like ""what can you add to the tree to cause a ___ rotation,"" how do you know exactly where the options are being added? cus cant they be put in multiple places",I think they're BSTs aren't they?,no its balanced the difference in heights between the left and right subtrees is 1,Well AVL^^
I think they're BSTs aren't they?,no its balanced the difference in heights between the left and right subtrees is 1,Well AVL^^,let me pull up an example rq hold on
all sequential in-order traversals could theoretically be the in-order traversal of some AVL tree right?,since in-order always prints out a BST tree sequentially,whether the root is 1 or 1000,but can't the current node be 7 or 13
is there an explanation for this one anywhere?,15 > 11 so you have to go right to 13 and 15 > 13 so it would be the right child of 13,OHHHHH,i think it would be b
why is it 11?,wouldnt 11 just cause a right rotation,Test in 20 min guys gl,@atl15 deleting 11 causes 10 to be unbalanced
wouldnt it just be a right shift tho?,So u need to do a left rotation on on 8 followed by a right rotation on 10,ohhhh,im stupid
"what's the process for online tests through prairietest? i took the first exam in person and i can't seem to find instructions for if we should join the zoom on pc or phone, or if there's something else to do",did u already sign up for a time slot on prarie test? if u did open the time slot and there should be a button to refresh for zoom information,yeah,"oh the link is there now, nice"
did u already sign up for a time slot on prarie test? if u did open the time slot and there should be a button to refresh for zoom information,yeah,"oh the link is there now, nice",like 10 min before the exam starts the zoom link should be there
and you just join through the device you're taking the test on?,it helps to notice that this is the state that causes a left right rotation,^,opposite shape for right left
@mm-is-here have u already joined the zoom call?,nope,now i have,is it completely empty?
is it completely empty?,or are they giving directions,there are 4 people here,no directions
oh so we do need to show our full workspace?,rip gotta clean my phone then,yeah,your desk
how do you solve these type of questions?,it has to be increasing,where you have to figure out what traversal type it is based on the order of nodes,"inorder = increasing, not sure about how to do preorder or postorder"
can you explain why?,"so we know that, for any node in an AVL tree, left child = less, right child = more
so if we have this tree:
```
  5
 /  \
2    10
```
the inorder traversal goes left, middle, right
so 2, 5, 10",oh okay got it,how would post and pre order go?
how would post and pre order go?,"post would be 2, 10, 5 right?","and pre would be 5, 2, 10",?
"post would be 2, 10, 5 right?","and pre would be 5, 2, 10",?,how do i know whether or not its possible if I dont know the type of traversal order
?,how do i know whether or not its possible if I dont know the type of traversal order,"should be the first one because when u get from 9 to its child 107, you will no longer have anything less than 9 but 4 is there","ohh, ok"
there wont be any red black trees on the exam correct?,"I guessed this one correctly, I can't seem to visualize this well",those if you recall from lecture are beyond the scope of this class,https://www.youtube.com/watch?v=WD2I2LEwpjQ
https://www.youtube.com/watch?v=WD2I2LEwpjQ,The vocals tho,Also why does every study song use I'll make a man out of you. Like I still remember the one for polyatomic ions,Every traversal has an O(n) running time right
is there a divergence from this?,Idk wym by divergence but yes it does have an O(n) running time as it visits every node,Way to make me feel old. This was made when I first came here. 🙃,like is there any case where a traversal does not have O(n)
"So 21 will go where 19 is, and 21's left child will be 19?",I think 21's left child would be 11?,and 11's right child would be 17 and 17's left child would be 13,https://wkdtjsgur100.github.io/avl-tree/
I think 21's left child would be 11?,and 11's right child would be 17 and 17's left child would be 13,https://wkdtjsgur100.github.io/avl-tree/,"-                21
               /     \\
           11
         /     \\
      7           17
   /            /   \\
5            13       19"
but wouldnt that be a tree with height 5 then?,Do you mean because of the (3+1)?,"because the 3 is just the height of the tree and the + 1 is always there.
If you don't see it then imagine a tree of just the root node thus of height 0. the max number of nodes it can have is 2^(0+1) - 1 = 2 - 1 = 1 which is true",And since it's a complete tree we know all the levels prior to the final level must be full that's where the 3 comes from and the final level must have at least 1 node so 2^(3+1) - 1 + 1 = 16 - 1 + 1 = 16
Do you mean because of the (3+1)?,"because the 3 is just the height of the tree and the + 1 is always there.
If you don't see it then imagine a tree of just the root node thus of height 0. the max number of nodes it can have is 2^(0+1) - 1 = 2 - 1 = 1 which is true",And since it's a complete tree we know all the levels prior to the final level must be full that's where the 3 comes from and the final level must have at least 1 node so 2^(3+1) - 1 + 1 = 16 - 1 + 1 = 16,You can also draw it out to double check
so a just a root node has a height of zero then?,and if it has a child then its a height of 1?,a perfect tree is just a full tree with all the leaves at the same height right?,I’m such a garbage test taker ugh
and if it has a child then its a height of 1?,a perfect tree is just a full tree with all the leaves at the same height right?,I’m such a garbage test taker ugh,I got three 5 point questions right but only got 2 points for each since I pick too fast and click submit without even thinking
a perfect tree is just a full tree with all the leaves at the same height right?,I’m such a garbage test taker ugh,I got three 5 point questions right but only got 2 points for each since I pick too fast and click submit without even thinking,:<
8 + 6 + 3 * 9 * 2 + 3 -.   Should it be 3 - at the end because left > current for  in-order ?,I sure miss paper exams cause I don’t get tempted to click submit each and every time,i know that feeling of wanting to full send it and hope to see green lol,i think so
"why is b incorrect? the worst case, non-amortized, for an insert is O(n), no?",The time complexity of each is not O(n) if that was true than d would not be correct. The time complexity of the one that has to copy is but that is not the same.,"Ok so for this question, I know that 3 must be the root and 1 must be its left child based on the pre-order traversal. Then I know two must be a child of 1 since the root of a subtree is printed last in that subtree. This allows me to eliminate all other answers. However, how would I be able to build the level order traversal beyond this? Do we need to know how?","oh
I thought time complexity is always worst case time complexity though?"
"Ok so for this question, I know that 3 must be the root and 1 must be its left child based on the pre-order traversal. Then I know two must be a child of 1 since the root of a subtree is printed last in that subtree. This allows me to eliminate all other answers. However, how would I be able to build the level order traversal beyond this? Do we need to know how?","oh
I thought time complexity is always worst case time complexity though?",isn't this an exam 1 question? I'm confused,The thing is that is not the right way to think about it any more than the right way to think about all this is that we could just say it is O(n!). It is not the worst case of each insert it is the worst case of the insert that has the copy. Another way to say is it is technically correct but not right.
"oh
I thought time complexity is always worst case time complexity though?",isn't this an exam 1 question? I'm confused,The thing is that is not the right way to think about it any more than the right way to think about all this is that we could just say it is O(n!). It is not the worst case of each insert it is the worst case of the insert that has the copy. Another way to say is it is technically correct but not right.,it's cumulative
isn't this an exam 1 question? I'm confused,The thing is that is not the right way to think about it any more than the right way to think about all this is that we could just say it is O(n!). It is not the worst case of each insert it is the worst case of the insert that has the copy. Another way to say is it is technically correct but not right.,it's cumulative,oh shoot
"Someone wanna explain this one to me?? **cropped out a bit: ""left subtree of the root""",If you only had the preoder  1 could be the left or the right but it must be a child. You can tell that 10 must be also be a child of the root since it is right before the root in the post order.,is it necessary to know how to find the the subtree of 10? I don't know how. It's unnecessary for this problem but I'm wondering if it could be on the test,We mean it can always be O(n) that is if you look at 10 times is there a sequence that can exist where they all take n. If not you should look at it using more complex techniques. Hence why this becomes the amortized.
is it necessary to know how to find the the subtree of 10? I don't know how. It's unnecessary for this problem but I'm wondering if it could be on the test,We mean it can always be O(n) that is if you look at 10 times is there a sequence that can exist where they all take n. If not you should look at it using more complex techniques. Hence why this becomes the amortized.,Would there be a way to have a single huge prairie learn practice exam with all of the unique questions? Because I feel like there are definitely some you can't get to unless you do a good 9 instances. And most of the time you get the same question just a different variation.,We could expect more construction. You can mostly build the fill tree. The only things you can not tell are if there is only one child which it is.
Would there be a way to have a single huge prairie learn practice exam with all of the unique questions? Because I feel like there are definitely some you can't get to unless you do a good 9 instances. And most of the time you get the same question just a different variation.,We could expect more construction. You can mostly build the fill tree. The only things you can not tell are if there is only one child which it is.,"so I'm able to distinguish were nodes go up until 10, but after that I'm kind of confused how we would go about it",I suppose I could but I don't think I will. In part I don't think grinding the practice a ton is particularly valuable but I do think seeing a representative sample is.
Happen to know which lecture that is in while I go dig for it?,Not off the top of my head but it should be the last one on AVL trees.,I think I found it. Watching the lecture now.,"1. If height = 0 then return 1
2. If height = 1 then return 2
3. If height > 1 then return (1 + getMinAVLNodes(h – 1) + getMinAVLNodes(h – 2))"
"Can someone share some experience in tackling those problems? I feel comfortable with RL LR rotations where it's a three-node stick, but in this case, it's node 17, and it's harder to visualize that. The correct answer is 15 btw.",What I do is I first check which numbers won't change anything,For this case it's 20 and 22,Try thinking back to the code we wrote in lab AVL tree. The requirement for a LR rotation was that the first node unbalanced had a left heavy balance. And their left child has a slightly right heavy balance
Why is the worst case remove for a binary search tree O(n)? Wouldn't find be O(lgn) and removing the node be constant time?,oh wait I'm an idiot,all the nodes in a line,sequential order from either end
can someone tell me how this is possible?,Isn't it impossible because you have no idea where the nodes go?,yeah pretty much,"Preorder is root first, post-order is root last, then use binary search tree characteristics"
Isn't it impossible because you have no idea where the nodes go?,yeah pretty much,"Preorder is root first, post-order is root last, then use binary search tree characteristics",using both you can figure it out but yeah it's pretty hard for me
"I get that, that's a really good explanation. But, why do we need a right rotation in this case at all, if  it makes any sence. There is a pretty good stick of 11 13 15, wouldn't one rotation left fix that?","oops wait mistake. 4 is a left child of 5, 12 is a right child of 10","@Ericgyc Basically in pre order, everything that comes after you MUST be a descendant of some kind. In post order, everything that comes before you MUST be a descendant of some kind. You can cross those to figure out where things are",certain numbers based on the pre order and post order MUST be descendants of some numbers but cannot be descendants of others
"does anyone know why 6 is right? I am trying to do a RL rotation on 5, 8, and 7. After doing the RL on those nodes, I get 7 as the root when 6 is the answer",17 would be the first node to be unbalanced and it is left heavy and it's left child is slightly right heavy. so you would need the 2 rotations. otherwise you would just end up with the same imbalance,"the order of rotations would first be single left, then right left","5,8,9 would require a single left"
i get why it's 15 here but why isn't it also 33?,You're ading 33 to the left of 35,33 wouldn't make it unbalanced,that would not unbalance it (it would actually make the tree better)
can someone take alook at this?,Was it C^,ignore my question,I read which one CAN be an AVL tree
"Has anybody run into a memory question in the practice exams and can share it? Like one that says how many bits like an int is, a pointer is etc and then you have to say how many bits are still in use at exit?","For this question, why is the answer 3? I only see two values being stored into i?",How do u traverse a tree on DFS?,"you use a stack, i think"
"For this question, why is the answer 3? I only see two values being stored into i?",How do u traverse a tree on DFS?,"you use a stack, i think","and the traversals you'd use are pre-order, post-order and in-order"
How do u traverse a tree on DFS?,"you use a stack, i think","and the traversals you'd use are pre-order, post-order and in-order","i is initialized with 0 so that's one
then updated to 2 so that's two
and since `*ptr = &i`, line 5 updates i again so three"
is there an example for where the answer is log?,"Also is there a striaght formula to do these problems without having to trace out T(1) T(2), etc","Is the worst time complexity of ""find"" for BST is O(n) and AVL tree is O(logn)?",I’m not 100% sure but I THINK just `newVal = &value` might also work
"Is the worst time complexity of ""find"" for BST is O(n) and AVL tree is O(logn)?",I’m not 100% sure but I THINK just `newVal = &value` might also work,That sounds right,"Thanks! So for AVL tree, is the worst case of find, delete, insert, etc. are all O(logn)? I remember that it'll be O(n) for BST"
"Thanks! So for AVL tree, is the worst case of find, delete, insert, etc. are all O(logn)? I remember that it'll be O(n) for BST",Yeah except to traverse I think traverse is O(n) for everything,Yep I'm pretty sure that traverse is always O(n) too. Thanks!,"For me I look at how quickly the problem gets smaller so in this case it’s only by 1 each time so it’ll take (n-1) to get to the base case and it’s doing 5 work at each level besides T(1) so
5(n-1) +1 or 5n - 4"
Can anyone explain this to me? The answer is O(n),"if you're at a node in an AVL tree, you could go left for the smallest, but there's a chance that subtree doesn't even have a multiple of 7, so you have to search the right as well","and since we're in worst case, this means we have to search the whole AVL tree, aka O(n)",Oh so that's because the key have a multiple of 7 might does not exist at all... which means that we should search every node of the tree. Thank you!
what does it say the correct answer is?,15,hmmm,i see why you chose 9
no?,no bc it'd be on the right of 7,What would the running time be to create an AVL tree with n nodes?,nlogn?
What would the running time be to create an AVL tree with n nodes?,nlogn?,cause you have to do n amount of inserts which take log n,is it bc it should be a left rotation followed by a right rotation and then nothing after that?
nlogn?,cause you have to do n amount of inserts which take log n,is it bc it should be a left rotation followed by a right rotation and then nothing after that?,I think you're right
is it bc it should be a left rotation followed by a right rotation and then nothing after that?,I think you're right,does a left then right not balance the tree?,nope
does a left then right not balance the tree?,nope,it doesnt,so maybe that's why
"if you insert 15, cant you just fix it with one right rotation?",@Lexapedia (렉시),or am i not doing it correclty,i see it now
Do you see anything wrong with what I did?,Or why I can't do that?,i dont think this is balanced? i could be wrong tho,since the 17 is the same level as the 7 so the 15 is two levels below? idk thats how i thought about it
Or why I can't do that?,i dont think this is balanced? i could be wrong tho,since the 17 is the same level as the 7 so the 15 is two levels below? idk thats how i thought about it,"This answer makes absolutely no sence, if my preorder traversal starts with 3, that means my root-node is 3. If my level order traversal starts with 3, then it's the left most node of the left root subtree."
i dont think this is balanced? i could be wrong tho,since the 17 is the same level as the 7 so the 15 is two levels below? idk thats how i thought about it,"This answer makes absolutely no sence, if my preorder traversal starts with 3, that means my root-node is 3. If my level order traversal starts with 3, then it's the left most node of the left root subtree.","And I draw it out and found that answer d is actually working if you do post order and prerecorded on it, you will get the same sequences as the rest"
since the 17 is the same level as the 7 so the 15 is two levels below? idk thats how i thought about it,"This answer makes absolutely no sence, if my preorder traversal starts with 3, that means my root-node is 3. If my level order traversal starts with 3, then it's the left most node of the left root subtree.","And I draw it out and found that answer d is actually working if you do post order and prerecorded on it, you will get the same sequences as the rest",i had the 12 as the right child of 5
what is the runtime of inserting n nodes into a BST? (Not AVL),Not sure if it's a typo but the level order does not start at the left most node of the left root subtree. It starts at the root then at the leftmost part of the next level then goes horizontally right the.... basically how you would read in English,I believe worst case would be O(n²) but not at all positive,The way I'm thinking is worst case is a stick so each insert you have to go down the entire thing so each one takes n time and there's n inserts to do
anyone know how to do this?,"keep in mind youre solving for the min number of nodes in a subtree, so you would have to calculate with a height of 6 or 5","in this case, since its an AVL tree, one subtree can have a height of 5 and the other can have a height of 6 and since we're trying to calculate the min, we would use 5",so you would just calculate for the min using that and that should give you the right answer
iirc a btree and binary tree are different right?,it was just a bad naming scheme or something,"yes, they are different",BTrees are not covered on this exam
I am currently signed up for the online section of exam at 7pm. Is it possible for me to still take it at CBTF earlier even though I already signed up for the online version? I dont want to cause any unnecessary confusion regarding scheduling accidentally,"yes
go to the cbtf website and change your session",can someone explain this,"First you make le tree. Then you push to the queue in level order, while dequeuing the parents (after?) queueing the children: ~~e~~,~~a~~, ~~j~~, **b**. I believe that's how."
"First you make le tree. Then you push to the queue in level order, while dequeuing the parents (after?) queueing the children: ~~e~~,~~a~~, ~~j~~, **b**. I believe that's how.","for this i just checked if each value is larger than the previous, is that right?",okay thank u sm,"since in order prints left, then right"
"for this i just checked if each value is larger than the previous, is that right?",okay thank u sm,"since in order prints left, then right",Ye
whats the difference between bst and avl?,is avl the ones with multiple keys?,"or no, thats btrees",oh avl trees are balanced based on the height
is avl the ones with multiple keys?,"or no, thats btrees",oh avl trees are balanced based on the height,Avl trees are balanced
"for this, to determine which letter goes left or right, can we assume that each letter corresponds to its alphabetical number? so a is 1 and z is 26?",so b > a,That's what I assumed.,"for this, you could swap places with either 5 or 7 right?"
"for this, you could swap places with either 5 or 7 right?",also im kind of confused about iop and ios,"iop is predecessor, but is below the current node? shouldnt it be above?","im so stuck on this one, i know all the traversals but i learned them with full and complete trees so im assuming this one has some missing children in some places and i have no idea how to navigate that"
"iop is predecessor, but is below the current node? shouldnt it be above?","im so stuck on this one, i know all the traversals but i learned them with full and complete trees so im assuming this one has some missing children in some places and i have no idea how to navigate that",for these ones when considering your options always make sure that the BST rules are still being followed - the wrong options will have incorrect BST trees,"right, but what was the actual algorithm for deleting?"
"right, but what was the actual algorithm for deleting?","for the cases where it's just a single child node or if it's a parent with one child or something you just remove it and that's that, but it gets tricky when it's a root node with 2 kids - here's the format",i'll send the others too,subroot node with only 1 child
oh wait unless you're talking about the actual code?,"so you know that the root is 3 because of pre-order starting at the root, and you know that 1 is left of three because pre goes left first. after that, 2 is a child of 1 because post prints the left most node and 2 comes before 1",no this is good,but why did you go from 50 to 60
What is the level of a root node is it 0 o 1?,height? would be 0,and are level and height the same thing,"uhhhh, i think?"
height? would be 0,and are level and height the same thing,"uhhhh, i think?","no level is just how many edges you've come down the tree, height is MAX level"
"uhhhh, i think?","no level is just how many edges you've come down the tree, height is MAX level",ahh,"so in this, what happens if you were to delete 50?"
"so in this, what happens if you were to delete 50?",one sec,So this tree has a height of 2 or 3,like how would you know whether to go left or right first
https://www.youtube.com/watch?v=jDM6_TnYIqE watch this video and go to around 30:40 this is how i learned it,height is 2,^,Thank you
so when calculating the maximum number of notes in a BST is it just 2^(height-1)?,im still stuck,that i do not know,"2^(h+1) - 1 works, from what ive found"
okay do you understand that 3 is the root?,yes,"then, in pre order, the next thing it would do is go left","once we go left, we are in a new recursive call, so we print again"
make sense so far?,yes,then you need to find if 1 has children,the easiest way to do that is check post order
"Just to make sure, the content of the exam is just Trees, BST Trees and AVL Trees, right?",I just saw a post on piazza talking about heap and stack memory and got worried,Does this hold for avl trees too?,it should
Does this hold for avl trees too?,it should,AVL trees are just BST trees that self-balance,Yeah
does anyone know how to solve for this question??,"i thought the tree would grow as 4 - 5 - 6 - 7 - 8 - 9 - 10 where they are all placed at the previous one's right child but that would just give 4,5,6,7,7,8,9,10 for the level order .. so im not sure if i understood the question correctly","i just organize the numbers into an avl tree (i ignore the ""insert in order"" part) and then i do the level order traversal and i seem to always get it right doing it like that",but isnt 4 still the root?
but isnt 4 still the root?,how did u figure out that 7 will be the root here,Even after inserting the first 3 points 4 is not the root.,It will be unbalanced and rotate to fix. Then continue looking at the inserts.
"I signed up for an exam on tuesday but I got hit by a truck and was hospitalized for 2 days, can I change my exam to be this afternoon? I think the emergency deal already sent the necessary materials",@gcevans,All such materials are handled by Thierry. You should be able to do so. If emailing cs225admin@lists.cs.illinois.edu did not get a response from @Thierry I would also reach out to the CBTF and see if they can fix it since it is still in the window.,Is there a specific strategy for taking a traveral and making into a tree if you dont know its height of which nodes are leaf nodes?
Is there a specific strategy for taking a traveral and making into a tree if you dont know its height of which nodes are leaf nodes?,ah this really helps. thank you!,Does anyone understand why this is?,holy sht are you ok?
Does anyone understand why this is?,holy sht are you ok?,The short answer is that there are multiple trees that produce those two traversals. You can see this as you go through the traversals. That makes it so you can build two trees that have different level order traversals.,there are multiple arrangements for a tree with that traversal
holy sht are you ok?,The short answer is that there are multiple trees that produce those two traversals. You can see this as you go through the traversals. That makes it so you can build two trees that have different level order traversals.,there are multiple arrangements for a tree with that traversal,I build all the trees in the anwser choices and only a worked
Did i do that incorrectly then?,probably,you can't really produce only one tree from the in order traversals they give you tbh,cause even those you could interpret in all sorts of ways
oh so it would not work because 401 would be the leaf of 399?,thanks,yes,specifically it would be in 399's left subtree
"did u recognize the hierarchy of the letters? like because b comes after a in the alphabet, it goes to the right of a in the tree",no i know that,i was totally lost until someone just explained it to me lol,oh ok
are all traversal times O(n)?,"not an answer to you, just a question sorry",All of the traversals we have covered run in O(n) time.,are we allowed scratch paper during the online exam?
are we allowed scratch paper during the online exam?,"if we’re taking the exam online, do we join the zoom link from a tablet/phone with our video to show our laptop screen?",Yes and yes.,im so lost
"if we’re taking the exam online, do we join the zoom link from a tablet/phone with our video to show our laptop screen?",Yes and yes.,im so lost,omg np dw
"so it's not like bubble sort because bubble sort doesn't depend on the pattern of inputs over repeated runs
but it doesn't really make sense to think about one input when it does depend on preceding runs for insert?",Again from a technical point of view it would be correct to say that every algorithm we have covered is O(n!) but it would be wrong on a test.,How would u do this one,"why is this wrong, isnt 4 the root node?"
"why is this wrong, isnt 4 the root node?",level order is BFS,"no, the root can change through rotations",7 is the root node because of left rotations
so we just assume its always going to rebalance since its avl?,Also in the case of bubble sort it is always O(n^2) best as well. There is an issue with how we use big-O and complexity in that we use it to best describe what is happening and saying worst case O(n) for insert is not wrong but it is also not right.,i thought the rebalancing would happen after adding everything,wait what page is this
Average for avl trees is always logn right?,unless you traverse it,or there are questions like best case which is o(1),traverse in this class is always O(n)
Worst case for AVL i believe is still O(n) tho correct?,yes agrred,not unless its traverse,also you could insert n items in that case its nlogn
idts? its O(h) for all and h in avl is log n,i feel like ive done all the variants,oh ok yea you're right @Frenzyfire,because in avl if u find u dont have to go to every node u just go from root to leaf in worse case
the answer is node b correct?,heres the BST,ya,why is a on the left
is left alphabetically lower and you have to fill it?,https://www.youtube.com/watch?v=IozGo2kwRYE,Here is an excellent video that goes along with that BST I put in there,3 min is all u need and you'll have this question down easy
https://www.youtube.com/watch?v=IozGo2kwRYE,Here is an excellent video that goes along with that BST I put in there,3 min is all u need and you'll have this question down easy,ah i see i left out the e and a nodes
Is this left rotation or right rotation?,"I'd assume it's left, correct?",yes,it is left
"I'd assume it's left, correct?",yes,it is left,okay
is there a formula i should know for this?,nodes + 1,We did a proof of it the first day talking about trees.,any1 have an explanation for this question?
any1 have an explanation for this question?,"And this is RL rotation, right?","If this said size += 50, would the answer be a?",I think it would be a compiler or runtime error because you have a function that's changing private variables?
"And this is RL rotation, right?","If this said size += 50, would the answer be a?",I think it would be a compiler or runtime error because you have a function that's changing private variables?,so it's out of scope?
"If this said size += 50, would the answer be a?",I think it would be a compiler or runtime error because you have a function that's changing private variables?,so it's out of scope?,"you're right that it would be a compile error, but its because x is trying to call a private variable"
I think it would be a compiler or runtime error because you have a function that's changing private variables?,so it's out of scope?,"you're right that it would be a compile error, but its because x is trying to call a private variable",ok yea
so it's out of scope?,"you're right that it would be a compile error, but its because x is trying to call a private variable",ok yea,So u need the correct scope on the public function call
What were the 3 operators u needed for iterators again?,"*, !=, and <?",or am i wrong on the last one,Why would it be O(n) if it’s an avl
"*, !=, and <?",or am i wrong on the last one,Why would it be O(n) if it’s an avl,Think about it @Itay(itayg2)
is this correct btw?,"operator*(), operator!=(), and operator++()",ahh it was ++,thank you
Does anyone know a proper way to solve these types of questions?,I had to do it intuitively and draw and scratch out a tree,build the tree looking at both lists at the same time,yeah thats what I did but are there any paterns that will help me build it faster?
yeah thats what I did but are there any paterns that will help me build it faster?,*patterns,i have not found one yet 😦,F
will the midterm have content from the 1st midterm as well?,"it says review, so safe to assume 1 or 2 questions?",So for this u just look at BFS for enqueued dequeued,Uhh yea im pretty sure
"it says review, so safe to assume 1 or 2 questions?",So for this u just look at BFS for enqueued dequeued,Uhh yea im pretty sure,draw out the tree
right?,yes,gg,Can someone explain what I did wrong and how it's 6?
Can someone explain what I did wrong and how it's 6?,this is what I got after doing RL,did you do a rotation after each insertion?,oh shit
did you do a rotation after each insertion?,oh shit,lmao i'm tripping,i forgot
how do we do these type of questions?,basically you build the tree using the order of the sequence,"and if you notice that at any point the visit ""jumps"" to the next node (i.e. there is no direct connection to the next node from the previous node), then you know that cannot be possible because you can only visit nodes sequentially",show some of the options and ill walk you through it
does anyone have a list of runtimes for single vs doubly linked lists?,does anyone have a list of runtimes for single vs doubly linked lists?,like the runtimes of the methods for those lists?,"like insert(), find(), and so on?"
does anyone have a list of runtimes for single vs doubly linked lists?,like the runtimes of the methods for those lists?,"like insert(), find(), and so on?",How are non-numerical BSTs sorted? By the position of the characters in the alphabet?
like the runtimes of the methods for those lists?,"like insert(), find(), and so on?",How are non-numerical BSTs sorted? By the position of the characters in the alphabet?,can this be explained
"like insert(), find(), and so on?",How are non-numerical BSTs sorted? By the position of the characters in the alphabet?,can this be explained,yeah
How are non-numerical BSTs sorted? By the position of the characters in the alphabet?,can this be explained,yeah,i saw someone say 4 2 but 2 nodes hanging wouldn't change the height? (nvm)
i saw someone say 4 2 but 2 nodes hanging wouldn't change the height? (nvm),^,A perfect tree with 15 nodes is height 3 right? So then you have 2 more nodes which to make a complete tree go to the left side on the next level.,What runtimes are not clear to you?
A perfect tree with 15 nodes is height 3 right? So then you have 2 more nodes which to make a complete tree go to the left side on the next level.,What runtimes are not clear to you?,got it. Thank you.,doubly linked lists
What runtimes are not clear to you?,got it. Thank you.,doubly linked lists,What about them?
What about them?,i tried looking in the video lectures and TA notes and couldn’t find the calculation for them,for doubly,I kind of forgot how we did them for doubly linked lists
Given that we will ask you to reason about them not just give runtimes what part confuses you?,The base runtimes in a vacuum are the same as for singly linked lists right? Dealing with 2 pointers vs one does not really change things. If you have more details you can talk about specific changes.,I guess the nearest to a general change is that in a singly linked list you can remove at one end in constant time even with head and tail but in a doubly linked list with head and tail you can remove from either end in constant time.,oh okay thank you. i get it
The base runtimes in a vacuum are the same as for singly linked lists right? Dealing with 2 pointers vs one does not really change things. If you have more details you can talk about specific changes.,I guess the nearest to a general change is that in a singly linked list you can remove at one end in constant time even with head and tail but in a doubly linked list with head and tail you can remove from either end in constant time.,oh okay thank you. i get it,"Was under the impression that since the left subtree has a height of h-1, and F(6) = 33, then 33 should be the answer"
Why couldn't it have a height of h - 2?,ah,makes sense,thanks a bunch prof
"it takes log(n) to insert one node into an avl tree, right?",yeah,how is it 26?,at 25 it would be unbalanced
how is it 26?,at 25 it would be unbalanced,why not 20 then?,"we want to make the left subtree right heavy for RL, right?"
why not 20 then?,"we want to make the left subtree right heavy for RL, right?",if you add 20 the balance is still fine at 17,2 vs 2 so difference of 0
"we want to make the left subtree right heavy for RL, right?",if you add 20 the balance is still fine at 17,2 vs 2 so difference of 0,"shoot, gotcha"
"so, then how do we differentiate when doing RL and LR then if we're only looking to make it disbalanced?",look at how the final node is going to be added,for right left it's an elbow that goes left after a right,"for deleting in a bst, instead of going left then right to find the iop, what if we went right then left?"
"for deleting in a bst, instead of going left then right to find the iop, what if we went right then left?",like what if we swapped 3 with 5 instead,"that's fine, that's IOS",there are two ways to remove parent with two children
Wouldnt iop be above the node tho?,"Cuz ""predecessor""",Yes the image is the iop(in order predicessor),Hmmm
general rule is 2^(h+1) -1?,yeah,same as BST,maximum number of nodes is a perfect tree
is there a tentative date for exam 3? will it be before thanksgiving break?,after thanksgiving break,thank the lord,does anyone know when the final exams are scheduled
?,"No final exam, we only have the final proejct",oh wut,wait how sure r u @Tabish
can someone explain this one?,idk why you'd need 4500 slots if you know ur only gonna have up to 2900 UINs,Hash tables should generally be a decent bit bigger than the data stored,Otherwise hash collisions can result in really long finds/inserts
"why not e, then?","""use no more memory than necessary""","100k would be pretty fast, but also overkill","Can't see why that would be an issue, if you have 2900 UINs and 2900 slots you should never run until a hash collision right?"
"Can't see why that would be an issue, if you have 2900 UINs and 2900 slots you should never run until a hash collision right?",Ok nvm i see where I went wrong lol,I suppose it's possible that UINs still hash collide,^
Hey can someone explain this question?,Well you should understand the interface to all those data structures and the Big-O running time of each one. Now you have to ask your self if you want to implement a dictionary using each one how would you do it and could you do it using only a constant number of calls to methods on them that run in strictly less than O(n) time.,Ahh i see thank you so much,"By the way, will this next exam be similar to the previous ones in the sense that past material will also be tested like things from exam 1 and 2 but just in less of a prominent fashion?"
"By the way, will this next exam be similar to the previous ones in the sense that past material will also be tested like things from exam 1 and 2 but just in less of a prominent fashion?",Yes,Ok thank you,"For this one, the answer is seperate chaining because you're probably going to have keys from A-z or 0-25 and you want a linked list branching off of each key to store however many words you may have beginning with that corresponding letter?"
"For this one, the answer is seperate chaining because you're probably going to have keys from A-z or 0-25 and you want a linked list branching off of each key to store however many words you may have beginning with that corresponding letter?","And linear probing wouldn't work because that would mean you have a closed hash table so basically you would need an array thats 10,000 long",The larger issue here is that range of the hash function is only equal to the number of letters in the alphabet.,But yes you have the idea. One way to look at is that separate chaining is better with a bad hash function. So if you are no sure of how good the function is you should choose that.
"Also what is a ""hash value"", is that just refering to the hash function, or something completely different?",A hash value is the output of a hash function.,"Yea I ended up figuring that out, thanks for the confirmation though!","I understand generally where the answer is coming from just from process of elimination, but usually I would think the running time would be like O(h) where h is the height of the ""tree"". What would be an example where your running time is O(logn)?"
"I understand generally where the answer is coming from just from process of elimination, but usually I would think the running time would be like O(h) where h is the height of the ""tree"". What would be an example where your running time is O(logn)?","Also stupid question, what does heapifyUp do again btw?",move something of higher priority up,When your tree of n items has a height of log n so anything that is O(h) is O(log n).
"Also stupid question, what does heapifyUp do again btw?",move something of higher priority up,When your tree of n items has a height of log n so anything that is O(h) is O(log n).,Ahh I see thank you
"Maybe I just have a conceptual error, but why is the answer 17, does Kruskals not just start with the minimum edge which would be 6?",there's a 3,"Ok that's true, but why is the answer 18 then?",What does disk seeks mean in this context?
"Ok that's true, but why is the answer 18 then?",What does disk seeks mean in this context?,my handwriting's not great but you can kind of get the idea,so a kruskals algorithm does or doesn't start at the minimum edge?
What does disk seeks mean in this context?,my handwriting's not great but you can kind of get the idea,so a kruskals algorithm does or doesn't start at the minimum edge?,it keeps grabbing the minimum edge that leads to an undiscovered node
so a kruskals algorithm does or doesn't start at the minimum edge?,it keeps grabbing the minimum edge that leads to an undiscovered node,I guess I don't understand does the question ask for the first minimum edge you would grab?,Because that would be 3 right?
I guess I don't understand does the question ask for the first minimum edge you would grab?,Because that would be 3 right?,it asks for which edge wouldn't not be included,not be included?
Because that would be 3 right?,it asks for which edge wouldn't not be included,not be included?,"But it asks which edge would be ""added"" to the MST"
not be included?,"But it asks which edge would be ""added"" to the MST",wouldn't that mean included?,sorry im confusing myself a bit
wouldn't that mean included?,sorry im confusing myself a bit,one second,no worries haha
I think inserting 10 will not cause the btree to split anywhere. am i right?,Yes,"Hey I just forgot, is ""smart union"" supposed to be union by height or union by size?","is 2 not valid because of the ""all leaves are on the same level"" property or the ""all internal nodes have ceil m/a up to m  children"" property?"
"Hey I just forgot, is ""smart union"" supposed to be union by height or union by size?","is 2 not valid because of the ""all leaves are on the same level"" property or the ""all internal nodes have ceil m/a up to m  children"" property?",Both are smart union and both provide the same runtime.,Well only the first is actually violated since what should be internal nodes are leaves.
"is 2 not valid because of the ""all leaves are on the same level"" property or the ""all internal nodes have ceil m/a up to m  children"" property?",Both are smart union and both provide the same runtime.,Well only the first is actually violated since what should be internal nodes are leaves.,"for this question, are we assuming that the path compression just happens after each union?"
"for this question, are we assuming that the path compression just happens after each union?",If a union is not on a root there must be a find to get the root.,"How does union(I, D) work?",So far my picture looks like that
"How does union(I, D) work?",So far my picture looks like that,I've been taking the first parameter and making that a child of the second param,"But since I is already connected to E, how would I union it to D?"
"But since I is already connected to E, how would I union it to D?",You would do a find and then union the roots. You can only union at the roots.,"So this case, when I do find on I, nothing would change because I is already pointing at E which is the root",Then I would unioning D to E because D has less size?
Then I would unioning D to E because D has less size?,Yes,Ok thank you,"Ok so sorry I'm still a little confused, how would union(F, E) work here?"
"Ok so sorry I'm still a little confused, how would union(F, E) work here?","since the root node of E has a greater size than just the root node at F, would F merge into the tree that E is currently in?",Like this?,No union all ways connects at the root. You should have written the code for this in MP mazes.
"since the root node of E has a greater size than just the root node at F, would F merge into the tree that E is currently in?",Like this?,No union all ways connects at the root. You should have written the code for this in MP mazes.,"In this type of question when it says ""left side winning"", does that mean the left side will be the bigger node or smaller node"
Like this?,No union all ways connects at the root. You should have written the code for this in MP mazes.,"In this type of question when it says ""left side winning"", does that mean the left side will be the bigger node or smaller node","so if I had that union below and they were both root nodes, which node would be my new root node after the union?"
"so if I had that union below and they were both root nodes, which node would be my new root node after the union?",If they are both roots and both of the same size then D would still be a root after union.,"Ahh I had the opposite, I understand now thank you","I'm a bit confused about this question about double hashing. When I insert 2 into the hash table, it will go in slot 6. Then when I go to insert 6, I  get a collision because 2 is already at index 6, so I need to do h1(6 + h2(6)). but that gives h1(13) which I don't know the value of since the hash function used is not explicitly given. Am I misunderstanding the question?"
"I'm a bit confused about this question about double hashing. When I insert 2 into the hash table, it will go in slot 6. Then when I go to insert 6, I  get a collision because 2 is already at index 6, so I need to do h1(6 + h2(6)). but that gives h1(13) which I don't know the value of since the hash function used is not explicitly given. Am I misunderstanding the question?","Mostly correct, except it should be h1(6) + h2(6)",Not h1(6 + h2(6)),So in that case your 6 goes in slot 13%8 = 5
"I'm a bit confused on how this is valid.  If everything is arranged on one level in alphabetical order, shouldn't D be the first node to get passed up as the parent? Then G afterwards?",consider the tree with only F in the root and ABD in the left of F. Now insert C into that tree. That would produce this tree if you split as 2/1.,When will the registration for online exam3 open?,I am afraid @mattox will have to answer that.
When will the registration for online exam3 open?,I am afraid @mattox will have to answer that.,what does option d even mean,i think D means both A and C
"oh so like ""both of them could be considered dictionaries""?",mk,"yeah so its basically, A could be considered a dictionary, C could be considered a dictionary, both A and C could be considered a dictionary, or neither could be considered a dictionary",mmhmm gotcha. Thanks!
"for a disjoint set, the root of the set stores the negative value of the number of elements in that set right?",I believe that is the implementation used in the MP at least yes,mk,and do we need to know or care about smart union by rank
isn't that just the shallow one is merged into the deep one?,"also for disjoint set problems when they say ""Assume smart-union by size, with the left side winning in the event of a tie."" this means the left argument wins right?",You should understand both union by by size and union by rank(height). You are correct about what that is.,And finally yes if left wins in ties it means that the left root will be the root of the unioned up-tree.
"also for disjoint set problems when they say ""Assume smart-union by size, with the left side winning in the event of a tie."" this means the left argument wins right?",You should understand both union by by size and union by rank(height). You are correct about what that is.,And finally yes if left wins in ties it means that the left root will be the root of the unioned up-tree.,"ok. so a problem saying ""Assume smart-union by size, with the left side winning in the event of a tie."" says the exact same thing as a problem saying ""In the event that the two sizes are equal, the first argument will be considered as larger than the second.""?"
"ok. so a problem saying ""Assume smart-union by size, with the left side winning in the event of a tie."" says the exact same thing as a problem saying ""In the event that the two sizes are equal, the first argument will be considered as larger than the second.""?","also for this one, BFS is O(m+n), but since we're considering worst case and the worst case is when m = n^2, we say O(n^2). Is that logic correct?",(and also wouldn't that technically make c also a correct answer?),"No, BFS is O(m+n) for an adjacency list, and O(n^2) for an adjacency matrix."
"also for this one, BFS is O(m+n), but since we're considering worst case and the worst case is when m = n^2, we say O(n^2). Is that logic correct?",(and also wouldn't that technically make c also a correct answer?),"No, BFS is O(m+n) for an adjacency list, and O(n^2) for an adjacency matrix.","The idea of setting worst case to m = n^2 doesn't work because it's not uniquely the worst case for all graphs that m is n^2 (consider a graph with three vertices and the maximum number of non-redundant edges). Even in the case that you could do that, why not have a worst case of O(n^3) at that point?"
(and also wouldn't that technically make c also a correct answer?),"No, BFS is O(m+n) for an adjacency list, and O(n^2) for an adjacency matrix.","The idea of setting worst case to m = n^2 doesn't work because it's not uniquely the worst case for all graphs that m is n^2 (consider a graph with three vertices and the maximum number of non-redundant edges). Even in the case that you could do that, why not have a worst case of O(n^3) at that point?","If you need the intuition for the runtime of the adjacency matrix, remember that the length of the  adjacency matrix for any given vertex will be |V| = n."
"The idea of setting worst case to m = n^2 doesn't work because it's not uniquely the worst case for all graphs that m is n^2 (consider a graph with three vertices and the maximum number of non-redundant edges). Even in the case that you could do that, why not have a worst case of O(n^3) at that point?","If you need the intuition for the runtime of the adjacency matrix, remember that the length of the  adjacency matrix for any given vertex will be |V| = n.",Ah ic. Thanks!,"I'm not quite sure about what the phrase ""left side winning"" means. Does that mean left side of the function union(B,A) (which is B) wins if A and B tie?"
"I'm not quite sure about what the phrase ""left side winning"" means. Does that mean left side of the function union(B,A) (which is B) wins if A and B tie?",Yes. I do want to understand what else it could mean?,Like which one is further left in the array?,Assuming the array is listed left to right ig
Yes. I do want to understand what else it could mean?,Like which one is further left in the array?,Assuming the array is listed left to right ig,OK. I can see that at least.
Like which one is further left in the array?,Assuming the array is listed left to right ig,OK. I can see that at least.,Yeah That’s what i thought
what about for DFS?,Same runtime,"There's nothing fundamentally different between DFS and BFS with respect to runtime, considered that they're almost the same algorithm",why does it rearrange like that
What confuses you about this? Do you remember how a btree works at all?,think about throwing the middle key up,and how we can only store up to m-1 keys per node,why can't we use heaps to represent a dictionary?
why can't we use heaps to represent a dictionary?,How do you implement find(key) with a heap interface?,The only functions you have are removeMin and insert?,ah I see thanks
How do you implement find(key) with a heap interface?,The only functions you have are removeMin and insert?,ah I see thanks,In a real sense we are moving to asking the real questions you will see using this material in the future. That is what data structures can you use to do task Z efficiently.
The only functions you have are removeMin and insert?,ah I see thanks,In a real sense we are moving to asking the real questions you will see using this material in the future. That is what data structures can you use to do task Z efficiently.,yeah
can someone explain why the first index is -6 and not -1? the rest of my array is correct besides that first index,It contains -size as it did in mp_mazes.,"Quick sanity check question: for btrees, I was under the impression that all internal nodes have exactly one more child than keys. However, I was able to create the following btree using the applet linked on the course website. 
Are 20 and 50 not internal nodes here? From what I can tell, they both have 2 keys and 2 children",They both have one key right. 20 only contains 20 and 50 only contains 50.
"Quick sanity check question: for btrees, I was under the impression that all internal nodes have exactly one more child than keys. However, I was able to create the following btree using the applet linked on the course website. 
Are 20 and 50 not internal nodes here? From what I can tell, they both have 2 keys and 2 children",They both have one key right. 20 only contains 20 and 50 only contains 50.,why isn't this a valid btree? is it because L goes to MOP when that would put MOP before L in the btree?,"Ah for some reason, I was under the impression that the lines were the keys..."
why isn't this a valid btree? is it because L goes to MOP when that would put MOP before L in the btree?,"Ah for some reason, I was under the impression that the lines were the keys...","I think this problem referenced that the btree was of order 4, which means that the DGLT is invalid. (I defer to prof in the case I'm wrong)","oh i thought order was the max number of keys in the node
so order 4 means that 4 are acceptable"
sorry if this has been asked before but does the # of attempts in the prarielearn prac reflect the actual exam or will it be closer to the past 2 exams?,Yea I was told by a friend that last year Primm's algo was on the midterm but I haven't encountered it in the practice tests yet,how representative is the practice test of the actual test in terms of breadth covered,i had a couple questions on it in the practice test
Will the runtime of Kruskal and Prim be tested?,You should understand the runtimes of both Prim's and Kruskal's.,when would we get the online cbtf link for exam 3?,"What's the fastest data structure for choice a,c,d and e?"
when would we get the online cbtf link for exam 3?,"What's the fastest data structure for choice a,c,d and e?",I think a dictionary of char to list/array would work for a if you want a purpose built data structure,"for c, BFS and store it as paths from v_s? so a 1d/2d vector as in solveMaze"
"What's the fastest data structure for choice a,c,d and e?",I think a dictionary of char to list/array would work for a if you want a purpose built data structure,"for c, BFS and store it as paths from v_s? so a 1d/2d vector as in solveMaze",this works for any destination from a given source
"for c, BFS and store it as paths from v_s? so a 1d/2d vector as in solveMaze",this works for any destination from a given source,you could reverse it to be any source to a given destination,"d, kd tree?"
"d, kd tree?","What would the actual solution to this problem be? I understand that you would want to have keys that have the minimum number of characters possible while still being able to differentiate the people, so would you just have the entire name as the keys?","The problem is that none of these solutions are correct. Consider the two groups {a,bc} and {ab,c}. This will not work for most also consider {aa,ab} and {ac,ad} which will not work for the first letters.","@gcevans Will we have to do smart-union by height on the exam at all, since I see that ""smart-union size"" is bolded on the prac exams signifying it can maybe change?"
"What would the actual solution to this problem be? I understand that you would want to have keys that have the minimum number of characters possible while still being able to differentiate the people, so would you just have the entire name as the keys?","The problem is that none of these solutions are correct. Consider the two groups {a,bc} and {ab,c}. This will not work for most also consider {aa,ab} and {ac,ad} which will not work for the first letters.","@gcevans Will we have to do smart-union by height on the exam at all, since I see that ""smart-union size"" is bolded on the prac exams signifying it can maybe change?",Can someone help me with this question please? I am not sure how to go about it. Is there a general formula for the number of cross edges?
"@gcevans Will we have to do smart-union by height on the exam at all, since I see that ""smart-union size"" is bolded on the prac exams signifying it can maybe change?",Can someone help me with this question please? I am not sure how to go about it. Is there a general formula for the number of cross edges?,and for back edges?,yeah
Can someone help me with this question please? I am not sure how to go about it. Is there a general formula for the number of cross edges?,and for back edges?,yeah,I remember a similar question like that too on a previous practice exam
and for back edges?,yeah,I remember a similar question like that too on a previous practice exam,Is the answer 4n+3?
Is the answer 4n+3?,Yes!,Here’s my approach,I recognised that the total number of edges is 5n+2
Would it be the same for back edges as well?,"similar concept, i think i've seen that question before so give me a second to look for it","this one, right?",Yeah
"this one, right?",Yeah,"yeah, it's the same idea, except they didn't give you the total number of edges","the keywords here then are: connected, undirected, degree 6"
Do you know how it would change if it were a directed graph?,if it was directed more details would be needed,cause in that case we could not guarantee that for every edge A->B it exists a B->A,it'd be very difficult for us to generally compute how many edges are
will the previous exam section have content from only exam 2 or both exam 1 and 2?,You should understand both.,Both 1 and 2.,not me trying to figure out how an AVL tree works again
is week 13 in midterm 3?,https://courses.engr.illinois.edu/cs225/fa2021/exams/exam3/,"okay, so i was on that link, i just missed mst at the end 😅",thanks
Does anyone know why the answer is none of them? I think it is because it is a normal spanning tree and not minimum but I'm not sure.,It is none of them since nothing about how it is build would ensure it is any of them. That is it could be true that any of them are true but there is nothing about this that makes any of them true.,"Oh so we basically need more information about the graph such as directed, connectivity, etc?","No, I am saying that the constraints on the spanning tree generated by DFS are insufficient to make any of those things true in all cases."
"Oh so we basically need more information about the graph such as directed, connectivity, etc?","No, I am saying that the constraints on the spanning tree generated by DFS are insufficient to make any of those things true in all cases.",I guess if the graph was a tree they would all be true but that it because there is only one path between two points on a tree.,ohh okay that makes sense
What if I just selected a bunch of random edges on a graph what would they tell me about the graph?,Nothing really.,Thank you,could someone explain this one
what happens to 1 and 0 after we do 2 5 7 3 ?,it moves down by the value given by the second function until it hits an empty spot,like h1(1) is 1 but that already had a 7 in it and so is h2(1) which i think is 3 is filled by 5,so
but we did check 3 before moving to 5th position right?,3 has 5 in it,ahh i see thanks,np
Thoughts on this one?,"19, 12, 9, 3, 5, 6, 7, 11",can someone explain me this?,why 4500 instead of 2900?
can someone explain me this?,why 4500 instead of 2900?,To many collisions at that point.,Is the answer O(1) because you are inserting at the front of a linked list everytime? (and that's always O(1))
why 4500 instead of 2900?,To many collisions at that point.,Is the answer O(1) because you are inserting at the front of a linked list everytime? (and that's always O(1)),Or just because it is initially empty?
Is the answer O(1) because you are inserting at the front of a linked list everytime? (and that's always O(1)),Or just because it is initially empty?,Since there is no order you can insert wherever is efficient so yes.,"Im kind of confused on how a btree works, especially each node can hold multiple keys and multiple children"
Or just because it is initially empty?,Since there is no order you can insert wherever is efficient so yes.,"Im kind of confused on how a btree works, especially each node can hold multiple keys and multiple children",how does it function as a BST?
how does it function as a BST?,does each key specifically point to children?,"```Which of the following statement(s) are correct about collision?

i) Two entries are identical except for their keys.

ii) Two entries with different data have the exact same key.

iii) Two entries with different keys have the same exact hash value.

iv) Two entries with the exact same key have different hash values.

(a) iii only
(b) i only
(c) i and iii only
(d) iV only
(e) ii and iii only```Why is ii not true, what is meant by entry data vs key?",is this beacuse you need to initially seek for top node of tree?
does each key specifically point to children?,"```Which of the following statement(s) are correct about collision?

i) Two entries are identical except for their keys.

ii) Two entries with different data have the exact same key.

iii) Two entries with different keys have the same exact hash value.

iv) Two entries with the exact same key have different hash values.

(a) iii only
(b) i only
(c) i and iii only
(d) iV only
(e) ii and iii only```Why is ii not true, what is meant by entry data vs key?",is this beacuse you need to initially seek for top node of tree?,Why is this heapifyDown instead of HeapifyUp?
"```Which of the following statement(s) are correct about collision?

i) Two entries are identical except for their keys.

ii) Two entries with different data have the exact same key.

iii) Two entries with different keys have the same exact hash value.

iv) Two entries with the exact same key have different hash values.

(a) iii only
(b) i only
(c) i and iii only
(d) iV only
(e) ii and iii only```Why is ii not true, what is meant by entry data vs key?",is this beacuse you need to initially seek for top node of tree?,Why is this heapifyDown instead of HeapifyUp?,I think so
is this beacuse you need to initially seek for top node of tree?,Why is this heapifyDown instead of HeapifyUp?,I think so,heapafiy down will only be called on n/2 nodes where heapafiy up will be called on n nodes
Why is this heapifyDown instead of HeapifyUp?,I think so,heapafiy down will only be called on n/2 nodes where heapafiy up will be called on n nodes,In a hash table you look things up by key and store data associated with it. This is roughly the dictionary interface we have talked about most of the semester.
"Can someone help with this one please? I dont understand why element 8's final value is 1 and not 3. I thought it was 3 because in the third union, 3 is the root with 8 pointing to it. So I thought 8's value would change to 3.  Then in the 4th union, it makes 3 point to whatever 7's root is (which is 1), so 3's value becomes 1. But I don't understand why 8's value becomes 1 as well.",The last union I think is why,you’d be unioning find(2) and find(8),since find uses path compression
find would get the root of the element?,some questions explicitly say no path compression,in which case you’d be right,yup
How would the answer change if you used path compression for this?,Im just wondering what the difference between path compression and no path compression would be here because I think I get the same answer,"This is sort of a trick question. Hash collisions are about values at hashes, independent of what structure they’re being used with. In practice, hash collisions would seem to cause two different data entries to get the same key but that is not the intrinsic definition of a hash collision!",I’d recommend doing both examples out! One you’ll just find roots every time you ‘perform a find’ and for the other you’ll edit the pointings when you ‘perform the finds’!
"What would the final array be if it were using path compression? Would it be [-1, 7, 7, 7, -1, 2, -1, -6, 7, -1]?",why does it go to 7 instead of 2,It’s linear probing and it’s asking what the most probable destination is,"It would only go to 2 if the hash happened to be 0, 1 or 2"
so basically there's some stats/probability involved in this one too?,What's the worst case runtime for DFS with Adjacency Matrix on a graph?,O(m+n) or O(n^2),for adjacency matrices you can't tell if the edge between any two nodes actually exists or not without checking it
What's the worst case runtime for DFS with Adjacency Matrix on a graph?,O(m+n) or O(n^2),for adjacency matrices you can't tell if the edge between any two nodes actually exists or not without checking it,so you have to check every entry
oh cus add the 9?,yeah,"For a minHeap implementation, if we store the root as index 0 opposed to 1 would the left child's position be 2i+1",and if we were to store root as 2 would the right child be 2i+3?
and if we were to store root as 2 would the right child be 2i+3?,I worked it out a few times but this is the diagram that I am getting,what does this mean exactly?,(BTree proprety)
what does this mean exactly?,(BTree proprety),oh nvm i think i understand,does this have something to do with load factor?
does this have something to do with load factor?,Yes but the key here is you don't are about memory so of the choices this will be the lowest load factor and thus the fastest.,wait what is the formula for load factor again?,elements divided by available slots
wait what is the formula for load factor again?,elements divided by available slots,but then wouldn't 100000 give the highest load factor,oh wait i think i got it backwards
In what sense?,"see here, i thought justin explained it well",In that context the description provided is good.,ahh nevermind I figured it out now
How do the inserted numbers correlate to the function? I am a little confused on how to approach this problem.,the hash function gives the index in the array at which to store the contents,"insert 1 -> (3 * 1 + 4) % 7 = 0 -> insert 1 at the 0th index of the array
insert 3 -> (3 * 3 + 4) % 7 = 6 -> insert 3 at 6th index of array
insert 8 -> (3 * 8 + 4) % 7 = 0 -> try to insert 8 at the 0th index, but encounters collision with 1 -> try next index over (linear probing) -> can insert there, 8 inserted at 1st index
and so on",Ohh ok thanks
"when it says it can store 80 elements, does that refer to the number of elements that are going to be stored? since the capacity is stated to be 100",yes,wait this is actually always true?,i believe so
wait this is actually always true?,i believe so,but it looks like every node has one more child than keys,"the leftmost internal node doesn't (0 children and 3 keys), the internal node in between 155 and 226 (0 children and 2 keys) doesn't"
how do I approach this problem?,Well since you know that each vertex has degree 6 you can compute how many edges there are and then subtract the number of edges that are discovery edges to get the number of back edges.,What about questions that say speed and memory are equally important?,Well then you should choose something that gets a load factor between .5-.7 to get the best compromise as described in lecture.
What about questions that say speed and memory are equally important?,Well then you should choose something that gets a load factor between .5-.7 to get the best compromise as described in lecture.,Thank you,for these how does not using path compression change it?
for these how does not using path compression change it?,if you had path compression you'd see almost everything pointing to one root,not sure for this specific problem but usually in find as you propagate up the tree you make everything you saw point at the parent,"without path compression you will still have a tree, but instead of everything rooted at one element, different elements will be rooted all over the place"
"when we do union by size, we are calling find on the two elements right?",so their paths would be compressed?,and then the union occurs?,Right since you have to find the root to do the union.
so their paths would be compressed?,and then the union occurs?,Right since you have to find the root to do the union.,ok thanks
and then the union occurs?,Right since you have to find the root to do the union.,ok thanks,"let's say we have to two following sets:
```         A          D
        / \        / \
       B   C      E   F
```"
"C path compresses to A (nothing happens), D path compresses to D (nothing happens), and then assuming left wins, D would be merged in as a child of A right?",not as a child of C?,Yes,yeah it would be a child of A
not as a child of C?,Yes,yeah it would be a child of A,"If it didn't use path compression, it would be a child of C?"
"If it didn't use path compression, it would be a child of C?",No in this case path compression makes no difference.,You always connect the root to the root.,So the resulting array would still be the same then with or without path compression?
So the resulting array would still be the same then with or without path compression?,In this case yes.,If for example it was `A-B-C` as the tree with the root at `A` it would be different since the path compression would change the line tree into the other one.,did you figure out how to do this one?
did you figure out how to do this one?,what load factor are we looking for?,If you don't care about memory the closer to 0 the better.,load factor = # elements / # slots in the array
what load factor are we looking for?,If you don't care about memory the closer to 0 the better.,load factor = # elements / # slots in the array,Ideally you want to have a table so large that your hash becomes a reversible function.
"but you don't want to choose the one with 100,000?",yeah you do,1800/100000 gives the smallest load factor out of all the choices,and they said they don't care about memory
"What does it mean when a hash function is deterministic? In my notes I have f(k1) (at time 1) = f(k2) (at time 2), but I am not sure what that means.",oh but if lookup was O(1) time that many elements would be bad and ruin the memory,The notes should have been `f(k1) (at time 1) = f(k1) (at time 2)`,That is you get the same value every time you use the function on the same value.
when you do DFS traversal on a graph does that MST represent anything?,it clearly isn't shortest path or longest path between any two nodes,What is DFS searching for? Is it looking at nodes or edges or both?,This is DFS as described in class as a traversal. That said in worst case it does not mater since you can make a graph such that the vertex is visited with the last edge.
What is DFS searching for? Is it looking at nodes or edges or both?,This is DFS as described in class as a traversal. That said in worst case it does not mater since you can make a graph such that the vertex is visited with the last edge.,What is the difference between these questions that changes the answer?,Adjacency list vs matrix?
What is the difference between these questions that changes the answer?,Adjacency list vs matrix?,The different running time in getAdjacent in the two graph representations.,So yes.
Adjacency list vs matrix?,The different running time in getAdjacent in the two graph representations.,So yes.,Ok. I get why adjacency matrix takes more time but why specifically n^2? Also why is adjacency list m + n?
Ok. I get why adjacency matrix takes more time but why specifically n^2? Also why is adjacency list m + n?,Well it takes O(n) to getAdgjacent and you have to do that at each vertex (n).,Why is it heapifyDown?,because we don't need to heapifyDown at leaves
Why is it heapifyDown?,because we don't need to heapifyDown at leaves,using heapifyUp in buildHeap is O(n log n) but using heapifyDown in buildHeap is actually O(n),Is there supposed to be too 7pm sections tomorrow?
Is there supposed to be too 7pm sections tomorrow?,Also is the exam at 6 in the morning or evening?,What is the running time of kruskals and prims algorithm? I keep getting conflicting info everywhere,Is one at DCL and the other at Grainger?
Also is the exam at 6 in the morning or evening?,What is the running time of kruskals and prims algorithm? I keep getting conflicting info everywhere,Is one at DCL and the other at Grainger?,Definitely evening lol
What is the running time of kruskals and prims algorithm? I keep getting conflicting info everywhere,Is one at DCL and the other at Grainger?,Definitely evening lol,No it’s the online section
Is one at DCL and the other at Grainger?,Definitely evening lol,No it’s the online section,"Oh I see, nevermind"
probably international kiddos?,Ye,can anyone explain how this is a back edge,DFS has back edges
BFS has cross edges (I think?),any1 understand this?,Are there not NO back edges on an undirected graph?,"uh
I think there are always n-1 edges ina spanning tree"
any1 understand this?,Are there not NO back edges on an undirected graph?,"uh
I think there are always n-1 edges ina spanning tree",so jusst subtract (5n+2) - (n-1) = 4n +3
Are there not NO back edges on an undirected graph?,"uh
I think there are always n-1 edges ina spanning tree",so jusst subtract (5n+2) - (n-1) = 4n +3,that's not an option is it
can someone explain this?,So is the answer not 6n - (n-1)?,because each verticie has degree 6,Can anyone explain this problem?
So is the answer not 6n - (n-1)?,because each verticie has degree 6,Can anyone explain this problem?,"Also, why is (ii) violated?"
Can anyone explain this problem?,"Also, why is (ii) violated?","I believe a would give a unique value. B wouldn't be unique (only taking first letters), C could be any order of the names (ie Megan, Ally, John could be arranged as MeganAllyJohn or MeganJohnAlly etc.), D wouldn't give a unique value, and E has the same problem as C but with sorted names (Megan becomes aegmn etc.).","If each vertex has a degree of 6, there are 3n edges because half of them are duplicates. 3n - (n - 1) = 2n + 1"
"Also, why is (ii) violated?","I believe a would give a unique value. B wouldn't be unique (only taking first letters), C could be any order of the names (ie Megan, Ally, John could be arranged as MeganAllyJohn or MeganJohnAlly etc.), D wouldn't give a unique value, and E has the same problem as C but with sorted names (Megan becomes aegmn etc.).","If each vertex has a degree of 6, there are 3n edges because half of them are duplicates. 3n - (n - 1) = 2n + 1",ohhhh I got it thank you!!
"To clarify, is the heap insert's runtime O(logn)?","7/8 of the time, the hashing function yields an even number",Oh that's right lol I couldn't even think about that at that time.... thanks!,Why is that the case?
Why is that the case?,"half the letters in the alphabet have an even number, so the probability of drawing an even is 1/2.  in order to generate an odd number in the hashing function, you would need to get 0 evens, which is 1/8, so probability of generating an even is 1 - probability of getting 3 odds","why did he only make 7,2,4,5 point to the root?",is it just any arbitrary value?
"why did he only make 7,2,4,5 point to the root?",is it just any arbitrary value?,This makes sense. Thanks,What does item I mean exactly?
is it just any arbitrary value?,This makes sense. Thanks,What does item I mean exactly?,"There is at most one more step from s to x than from s to y. If s to y takes 4 steps, s to x takes either 4 or 5"
What does item I mean exactly?,"There is at most one more step from s to x than from s to y. If s to y takes 4 steps, s to x takes either 4 or 5",so vertex s is original starting point of BFS? reading the question made me think that s was at most one level above x and y,Yeah. The problem executes BFS from vertex s which makes s the start
so vertex s is original starting point of BFS? reading the question made me think that s was at most one level above x and y,Yeah. The problem executes BFS from vertex s which makes s the start,Technically s doesn't have to be the start... the most important part of that question imo is that x and y are *adjacent*... s is really just a parent node/common ancestor,Maybe vertex s is not necessary the start?
Maybe vertex s is not necessary the start?,But yeah they are adjacent and have a common ancestor so the same logic applies,"For this one, why would it be back edge?","I think because 5, 0 is discovered through DFS, 0, 5 becomes a back edge"
"For this one, why would it be back edge?","I think because 5, 0 is discovered through DFS, 0, 5 becomes a back edge",So how exactly would that table be read? Would i start at vertex 0 and since 1 is first on list then i go to vertex 1. Then i see first element for vertex 1 is 0 so i skip it and then go to vertex 4. And then repeat the pattern like that?,Exactly
So how exactly would that table be read? Would i start at vertex 0 and since 1 is first on list then i go to vertex 1. Then i see first element for vertex 1 is 0 so i skip it and then go to vertex 4. And then repeat the pattern like that?,Exactly,Do we only get 1 attempt per question on this exam?,Thanks
Do we only get 1 attempt per question on this exam?,Thanks,Does anyone know why the first statement would be true here?,In this question why does 'I' become the root
Does anyone know why the first statement would be true here?,In this question why does 'I' become the root,Isn't 'B' to the left of 'I'?,Left is in the arguments to the function.
Isn't 'B' to the left of 'I'?,Left is in the arguments to the function.,Ohhh,Thought it meant of the array
"After traversing from 6 to 2 to 0, is 0 guarantied to be a back edge?",Can a key in a dictionary data strucutre have multiple values?,or is everything supposed to be 1 to 1,It cannot because you would not be able to tell which one you want to access
Can a key in a dictionary data strucutre have multiple values?,or is everything supposed to be 1 to 1,It cannot because you would not be able to tell which one you want to access,Yea that's what I thought
what about this one?,Removing the last item is not really something you’d want to particularly do in a dictionary,In that sense how do you decide what the last element is,Yea
But removing and inserting are both operations no?,Removing for a given key sure,and find a key given a value is also an operation?,Right cause it wouldn’t do much to have a dictionary you can’t read from
and find a key given a value is also an operation?,Right cause it wouldn’t do much to have a dictionary you can’t read from,Oh,Wait
the incorrect one?,Aren't we looking for the correct one tho?,Wait is it asking for the right one or the wrong one in the list,right one
Aren't we looking for the correct one tho?,Wait is it asking for the right one or the wrong one in the list,right one,Cause I think a and c are both wrong
"So generally with dictionaries, you can't use values to insert, remove, or look things up?",The justification is that you do things with keys,Not really the values,In a dictionary
can someone explain and give me like an example of how 2 would work?,2 cant work. It wants statements that are false,It technically can be a function but it would be a hash function,"Returning something mod 11 and changing the integers so it returns to a string without the trailing 0s follows 2s rules because ""10"" is possible and so is ""1"" which makes it variable length"
Which specific data structure fulfills this requirement?,I think it’s the avl tree,I think so too,Searching in any of these is worst case O(n) besides AVL tree
"does anyone know in which lecture notes are cross,discovery,back edges in?","what *does* it represent, if anything?",no one answered this when I asked so... no idea 😛,i forgot which algorithm uses cross edges and which uses back edges?
"what *does* it represent, if anything?",no one answered this when I asked so... no idea 😛,i forgot which algorithm uses cross edges and which uses back edges?,Because I think that back edges would be what is needed to detect cycles
i forgot which algorithm uses cross edges and which uses back edges?,Because I think that back edges would be what is needed to detect cycles,it doesnt represent the longest or the shortest anything. its just that- a path from u to v,"because its not using greed like in prim and kruskal, its just a random path"
"sry if this has been asked but shouldn't (I) be violated here? Since the function does not consider the order of the 3 letters, the keys abc and cab for example would come out as the same key when they should be unique",No deterministic means it would hash to the same thing every time,Like u don't want abc to be able to hash to 2 different indices,oh gotcha thanks
"Does anyone know how to walk through this? When I input it the same way as the answer, I don't get how it works out because of the second hash function",This question as well because I don't see how the second hash function fulfills the correct keys for the answer,can anybody explain why the 2nd one also doesnt work?,I have another question about this problem: how does it not distribute keys uniformly over the array?
can anybody explain why the 2nd one also doesnt work?,I have another question about this problem: how does it not distribute keys uniformly over the array?,Consider how many strings add to  1 vs how many are 37.,I comes after F.
I have another question about this problem: how does it not distribute keys uniformly over the array?,Consider how many strings add to  1 vs how many are 37.,I comes after F.,Oh lol
What does a hash table's capacity mean?,The size of the array.,why is the answer for this specifically n^2?,like i get that you have to read a linked list n times
why is the answer for this specifically n^2?,like i get that you have to read a linked list n times,worst case the list is O(n) and you are making n searches.,oh i see
"Why is the worst case runtime of DFS O(n^2), not even O(m + n)?",Ask yourself what is the running time of getAdj on an adjacency matrix.,Oh I got it!! Then does the adjacency list will have O(m+n)?,Yup.
Oh I got it!! Then does the adjacency list will have O(m+n)?,Yup.,how do you find the number of disk seeks to find in a btree?,@mattox do you know where the zoom link is for the online exams?
how do you find the number of disk seeks to find in a btree?,@mattox do you know where the zoom link is for the online exams?,what is a discovery edge,?
@mattox do you know where the zoom link is for the online exams?,what is a discovery edge,?,It's anything that's not a back/cross edge
?,It's anything that's not a back/cross edge,"so there's always n-1 of them, assuming the whole graph is connected",Did you get in? Because I still don't have the zoom for my online exam.
Did you get in? Because I still don't have the zoom for my online exam.,same here,im super confused about path compression,can someone show an example step by step
can someone explain this conceptually?,https://courses.engr.illinois.edu/cs225/fa2021/resources/heaps/,"look at section ""Turning an unordered complete tree into a binary heap""",can someone please explain the difference between cross and back edges like i know ones for bfs and one is for dfs but whats the difference other than that
can any1 explain this question?,What does an equivalence relation over a finite collection of elements mean?,https://www.geeksforgeeks.org/tree-back-edge-and-cross-edges-in-dfs-of-graph/,that might help
What does an equivalence relation over a finite collection of elements mean?,https://www.geeksforgeeks.org/tree-back-edge-and-cross-edges-in-dfs-of-graph/,that might help,idk tho
Btw anybody remember the equation that gives the number of edges visited in a traversal?,uhh for an MST it's n-1 edges?,@Ericgyc it was for this problem,"i just noticed I have no clue what's on mt3, time to study"
uhh for an MST it's n-1 edges?,@Ericgyc it was for this problem,"i just noticed I have no clue what's on mt3, time to study",or sleep first
"are we gonna have to do calculations like how many nodes/keys in a BTree or what the order is, etc.?",or just know the properties/structure of it,ik only the properties/structure is listed on exam 3 site but im just wondering,isn't btree mt2?
isn't btree mt2?,naw it's listed on exam 3,I mean stuff from mt2 will be on mt3,i think so yea
is there anything specific that confuses you?,will the exam also be only one attempt per question?,"there's that stupid problem where the inputs to a function are either *x, *y or &x,&y",btw anybpdy know how to explain the answer to the problem i posted?
will the exam also be only one attempt per question?,"there's that stupid problem where the inputs to a function are either *x, *y or &x,&y",btw anybpdy know how to explain the answer to the problem i posted?,is it the one you just mentioend
btw anybpdy know how to explain the answer to the problem i posted?,is it the one you just mentioend,mentioned,or a different one
"for unionize(a,b) does b point to a?",im not sure im not there yet im doing hashing rn,oh ok,sorry 😦
what about if they are not the same size?,Do we also need to know the difference in the runtime when we use a different type of priority queue?(heap / sorted array),The smaller size one should point to the bigger size one!,does anyone know what counts as a discovery edge
Do we also need to know the difference in the runtime when we use a different type of priority queue?(heap / sorted array),The smaller size one should point to the bigger size one!,does anyone know what counts as a discovery edge,?
?,i think its an edge to a node that wasnt visited yet @Yumple,anybody know why E is -6 instead of -5?,so after the traversal it is also never visited?
anybody know why E is -6 instead of -5?,so after the traversal it is also never visited?,you mean if you traverse a discovery edge to go to a new node? if u do that it becomes visited,"this tree is invalid, but why?"
so after the traversal it is also never visited?,you mean if you traverse a discovery edge to go to a new node? if u do that it becomes visited,"this tree is invalid, but why?",wait a minute
you mean if you traverse a discovery edge to go to a new node? if u do that it becomes visited,"this tree is invalid, but why?",wait a minute,I'm stupid
"this tree is invalid, but why?",wait a minute,I'm stupid,I just counted the arrows
"im getting kinda confused by all the properties of a btree, was this wrong because the root can only have max m - 1 keys?",And because a node always has one more child than keys.,ah yes,tysm
so then D gets updated to point to its root of I?,I think?,or does path compression not happen there,wait I'm dumb
I think?,or does path compression not happen there,wait I'm dumb,nvm
what would be our runtime if we made A hash table using probing with capacity of the same number X?,not good.,find would on average have to look through like half the array I think,so O(n)?
so O(n)?,what,"this data structure scares me
also why do we need a boolean at all? just check if the key is in our dict",can someone explain this
"this data structure scares me
also why do we need a boolean at all? just check if the key is in our dict",can someone explain this,shouldnt you be removing value not key?,The entry is the value
shouldnt you be removing value not key?,The entry is the value,for these questions do we just follow the order that they give in the table for DFS,"im kinda confused what that table means; say we start at 0, by what order is listed we go to 1, then at 1, the order has 0 but we visited so we go to 6?"
"im kinda confused what that table means; say we start at 0, by what order is listed we go to 1, then at 1, the order has 0 but we visited so we go to 6?",what are the answer choices?,i think i figured it out ty though 🙂,however i am confused on this one idrk a quick way to do these
what are the answer choices?,i think i figured it out ty though 🙂,however i am confused on this one idrk a quick way to do these,"@Hanforallckskyslikcaprifest @Valentino The orders in the adjacency list is just a way to define what other vertices are connected to said vertex. So for vertex 1, vertices 0 and 6 and 5 and 3 are connected to it. I think the ""left-to-right"" terms is just telling what order the programmer chose to add to the graph; it's basically arbitrary. Hope that makes sense?"
"@Hanforallckskyslikcaprifest @Valentino The orders in the adjacency list is just a way to define what other vertices are connected to said vertex. So for vertex 1, vertices 0 and 6 and 5 and 3 are connected to it. I think the ""left-to-right"" terms is just telling what order the programmer chose to add to the graph; it's basically arbitrary. Hope that makes sense?",is the answer C?,no it was only 2,"figuring out that (i) and (iii) are true for that hash function is relatively straightforward. Deterministic means that if you take the same input (k in this example) and run it through the hash function multiple times, everytime that specific input will hash to the same value, so (i) is true. Since its just pretty simply math, its easy enough to figure out. Similarly, since the hash function just does a few constant operations, (iii) will be true too."
is the answer C?,no it was only 2,"figuring out that (i) and (iii) are true for that hash function is relatively straightforward. Deterministic means that if you take the same input (k in this example) and run it through the hash function multiple times, everytime that specific input will hash to the same value, so (i) is true. Since its just pretty simply math, its easy enough to figure out. Similarly, since the hash function just does a few constant operations, (iii) will be true too.",could u explain what uniform distribution is? i watched videos/lectures but am only kind of getting it
could u explain what uniform distribution is? i watched videos/lectures but am only kind of getting it,this all makes more sense though tysm,I'm pretty sure option 2 is saying that it distributes all the values in the original array at least relatively equally across the hash table.,I'm pretty sure the hash function/equation they listed violated (ii) because of the 2k^2 + 2k. You can kind of deduce that the resulting values aren't going to be evenly distributed from 0-9 at all.
"and since like half (?) of these indices are going to be left out, it doesn't distribute the keys very uniformly across the entire array.",I hope that's the explanation?,okay that makes more sense,yes thank you guys so much
I hope that's the explanation?,okay that makes more sense,yes thank you guys so much,i think i just need to practice more
"So like an example of (i) would be 42 and 42: they're identical entries, but it's also saying, somehow, that their keys are different???",Like that would just be absurd.,I thought that is a possible scenario? Because what if we had a function who happened to map two different keys to 42?,This case is only enumerated by answer choice three
I thought that is a possible scenario? Because what if we had a function who happened to map two different keys to 42?,This case is only enumerated by answer choice three,"Like if the function is f(x) = x % 10, then both f(17) and f(27) = 7. So wouldnt these be identical entires except for the key which is a collision?","Think about the wording of your example, two keys are mapped to the same index"
"Like if the function is f(x) = x % 10, then both f(17) and f(27) = 7. So wouldnt these be identical entires except for the key which is a collision?","Think about the wording of your example, two keys are mapped to the same index","They are two distinct keys but being mapped to same value by function, so that would be a collision?","The key is 17/27, the hash fxn is f(x) = x % 10, and the returned index is 7"
"They are two distinct keys but being mapped to same value by function, so that would be a collision?","The key is 17/27, the hash fxn is f(x) = x % 10, and the returned index is 7",Yes,17 and 27 are technically different entries
why is (i) also true?,sometimes the only way to learn how a pointer works is to get it wrong on an exam 3 times in a row 😔,just not sure how to prove it,I think i may be misunderstanding the concept. I thought in this context 17 and 27 are different keys with same output in function. Which satisifes the definition of i of having everything identical(value produced by hash funcrion) except the key
unless you have to account for there being multiple copies of any given book?,But how can we confirm they are adjacent? Because it only says they are simultaneously on queue,I think it would actually take up less space since you're concatenating book + patron instead of doing the two separately; killing two birds with one stone (for the key).,(for the book patron dictionary one): but idk I don't like that question. I feel like the other answer choices would also work technically tbh.
But how can we confirm they are adjacent? Because it only says they are simultaneously on queue,I think it would actually take up less space since you're concatenating book + patron instead of doing the two separately; killing two birds with one stone (for the key).,(for the book patron dictionary one): but idk I don't like that question. I feel like the other answer choices would also work technically tbh.,"but if we have 3 books, like
Lord of the Rings
Harry Potter 1
Enders Game

and two patrons, let's say you and me

then our map would look like this:

Lord of the RingsJohn -> false
Harry Potter 1John -> false
Enders GameJohn -> false
Lord of the RingsMaaheen -> false
Harry Potter 1Maaheen -> false
Enders GameMaaheen -> false

as opposed to

Lord of the Rings -> none
Harry Potter 1 -> none
Enders Game -> none"
yall still don't have the link?,Yes same pls help,nope,thank u 🙂
did 9 am get the link yet?,not yet,Nooo whyy 🥲,ok same
should we contact the staff?,i contacted a ta,"any luck so far, guys?","Prof, what's the plan?"
"any luck so far, guys?","Prof, what's the plan?",I am trying to find out what is happening.,links there
"Prof, what's the plan?",I am trying to find out what is happening.,links there,am I correct in remembering the AVL tree is the only one of these with all the functions better than O(n)?
am I correct in remembering the AVL tree is the only one of these with all the functions better than O(n)?,I already got this as the right answer I'm just wondering if it's specifically the AVL tree that has them all better,also what's special about the hash table capacity of 4500?,"Yes, a stack and queue require you to remove every element at worst to find an element"
also what's special about the hash table capacity of 4500?,"Yes, a stack and queue require you to remove every element at worst to find an element",A binary search tree has no promises about its height so it could essentially just be a fancy linked list,A linked list at worst would also require an O(n) find
"Just confirming, edge(a,b) is same as saying edge(b,a)?","For undirected graphs, yes","Okay, thank you",are there gonna be 25 questions as well on the test with all only 1 attempt?
are there gonna be 25 questions as well on the test with all only 1 attempt?,"iirc 15 questions, two attempts each",So basically like all your past midterms,oh ok cool thanks
"is 1 invalid because the root should have 5 children, and is 2 invalid because ""I"" is out of order?","1 is invalid because at most a tree of order n can have n - 1 keys in any node, but the root has n (4 in this case) keys
and yeah you're right about 2",What if it’s a directed graph? Does a point to b or vice versa?,does the identifier have to be unique?
What if it’s a directed graph? Does a point to b or vice versa?,does the identifier have to be unique?,"(a,b) would typically mean edge going from a to b",b and c seem like they ignore the order of the names in the original set so they look fine
does the identifier have to be unique?,"(a,b) would typically mean edge going from a to b",b and c seem like they ignore the order of the names in the original set so they look fine,I'm confused why none are correct
why would linear probing not work?,"uh
there are only 26 possible hashes",you will get a big clump near the first 26 entries,and the rest of your hash table will be empty
but wouldnt it trickle down for empty space?,as duplicates occur?,what would be a valid key function for this scenario?,sort the names and then concatenate the whole names
as duplicates occur?,what would be a valid key function for this scenario?,sort the names and then concatenate the whole names,that's unique for an unordered set of names I think
what would be a valid key function for this scenario?,sort the names and then concatenate the whole names,that's unique for an unordered set of names I think,wait so when you say sort
im assuming the latter?,billy-bob-brownie-venkat,so yeah the latter,"and then concatenate, and that becomes one key?"
"and then concatenate, and that becomes one key?",oh cuz its  a set of students to a study group,not just one,okay yeah
Don't understand questions like this in general. What if the data were multiples of 5s or 10s? Its obviously not a great hash function then,Do these questions not rely on an understanding of the data?,"if someone knows your hash function, then unless it's cryptographic they can troll you by generating things with the same hash",I think we're assuming the user is not purposefully trying to annoy you so the integers are randomly distributed
Do these questions not rely on an understanding of the data?,"if someone knows your hash function, then unless it's cryptographic they can troll you by generating things with the same hash",I think we're assuming the user is not purposefully trying to annoy you so the integers are randomly distributed,ya i dont really get this question as well
Was there a closed form somewhere for how to make these calculations? What should our reasoning be?,"^Also fyi both the answers I have selected here were incorrect. the correct answers were 2n + 1 and 4n + 3, respectively",for the second one,the number of discovery edges will always be n - 1
did we learn about the array representation for doing union by rank?,I am not sure how that works,hmmmmm ya i think so but all the questions i got were by size,We did you store -(height +1)
oh no we didnt we learnt only by height and by size right?,rank is height,oh height,is rank
maybe because its only hasing 7 unknown values not too sure>?,"basically you check if h1 is open, if not add h2 and see if that is open, and if not keep adding h2 % size until you find one that is open","but like
it isn't an even distribution T_T
I get that it's close enough that it really does not matter",why is the answer c?
why is the answer c?,they change q to point to the address of r,what exactly does it mean for a hash function to be deterministic?,no random number generation
what exactly does it mean for a hash function to be deterministic?,no random number generation,I think,"oh, ok"
what does *q = 6 do then?,that is changing the value of r to 6,"can anyone explain these 2, i got them right but idk how path compresssion plays a role in the first question  vs the second question",i can show the drawings of each of these 2 as well if someone can explain
ya so union in these questions does find as well?,All union operations do find,"so if they ask ""what's q?"" it's asking for an address, if the question asks ""what's *q?"" it asks for a value",can we assume that we can determine the index for the letter in constant time?
"so if they ask ""what's q?"" it's asking for an address, if the question asks ""what's *q?"" it asks for a value",can we assume that we can determine the index for the letter in constant time?,crap idk what a union is,"Bc they need to locate the representative of the djs, they run find on the branch of the inputs"
can we assume that we can determine the index for the letter in constant time?,crap idk what a union is,"Bc they need to locate the representative of the djs, they run find on the branch of the inputs",can we assume that we can find the alphabet positions in constant time?
can we assume that we can find the alphabet positions in constant time?,Union is just connecting two disjoint set trees together,oh,^
I know that lower load factors give faster runtimes but is there a function directly relating them?,"Like, what range of load factors would give O(1), O (log n) or O(n) times?",yeah I have no clue how the number 4500 comes up,"I just think ""the number should be bigger than 2900 but not too big"""
"Like, what range of load factors would give O(1), O (log n) or O(n) times?",yeah I have no clue how the number 4500 comes up,"I just think ""the number should be bigger than 2900 but not too big""","if you're doing union by height/rank path compression isn't a thing you can do, right?"
"if you're doing union by height/rank path compression isn't a thing you can do, right?",and I pick one,?,"Yeah, same here. Feels like a very arbitrary number rn"
?,"Yeah, same here. Feels like a very arbitrary number rn",I think the alphabet is an array so yes,like accessing an array is O(1)
would I have to manually check all of these answer choices?,it also mentions that there needs to be some efficient use of memory,so if we use 1000000 its not really efficient,so thats y its 4500
nlogn?,oh it's just logn,vasilis has discovered a log n sorting algorithm,isn't the avl tree logn?
isn't the avl tree logn?,oh,heapsort performance is nlogn but heapifydown is logn,yes
how does using path compression vs not using it change the answer to this?,path compression makes it so that every time you make a union it attaches the one set to the root,without path compression it just attaches it to the thing,or wait
is there a sheet that says everything I need to know for the midterm?,oh there is on the website,Does anyone know why specifically it's b for this question?,I get that e doesn't work because the dictionary maps from strings to whatever the study group identifier is
Does anyone know why specifically it's b for this question?,I get that e doesn't work because the dictionary maps from strings to whatever the study group identifier is,Is the reason we choose b because concatenating the students names would be the most unique option for the key of each group?,that is what I assume
Is the reason we choose b because concatenating the students names would be the most unique option for the key of each group?,that is what I assume,you need unique keys,I'm guessing purely concatenating the names might cause issues with accessing
what's a smart union?,its the 2 different types of unions,smart union by size and rank,oh they're all smart unions
"also are all heap operations (heaifydown, up, insert...) O(logn)? I know heapsort is nlogn",basically,buildheap is O(n) tho,^
isn't that only in certain cases?,i think u also use heapifydown forn buildheap or something,lie that,also for this question
if its not a perfect tree u would use heapifyUp?,no clue,I think in my lab_heap I just used insert cos I'm lazy,lemme check tho
ya i thought it was always heapifyDown?,the heap itself has no insert function,always heapifydown,wait
what are disk seeks?,Think about them as operations to load a chunk of something from disk to memory,why is linear chaining bad here,"So for the question you’re asking about, its how many times u need to load an array to memory"
Do u mean separate chaining?,nah separate chaining was the right answer,i meant linear probing,Well Linear probing does very poorly if data is really contiguous
separate chaining usually works better with big collections right? because it works with linked lists?,nah I think it uses vectors,might be wrong,Traditionally separate chaining uses linked lists.
why’s that?,@Khushi Jain make sure you are ignoring empty entries,Since it gives non-amortized constant for everything that matters.,Remember that the ith guess to hash k is $h_1(k)+ih_2(k)$
and then mod 9?,5 does not go to 2,we are supposed to add the hash functions?,Neither does it go to 7
we are supposed to add the hash functions?,Neither does it go to 7,5+ 2,That is the formula yes
so if h1 does not work out you do h1 + h2?,"Start i at 0, and if $h_1(k)+ih_2(k)$ is taken, increment $i$ for your ‘next’ guess",**Garrett Credi(ddxtanx)**,what do you mean start i at 0?
what do you mean start i at 0?,"Double hashing is almost exactly linear probing, just remember that we dont increment guesses by 1 for double hashing, we increment them by $h_2(k)$",**Garrett Credi(ddxtanx)**,so it goes from 1 to 3?
so it goes from 1 to 3?,because 1 has been filled?,"The first time you want to try and get a hash value from $h_1(k)+ih_2(k)$ we know what $k$ is (it’s what we want to hash) but we need to choose an initial $i$ value. If we choose $i$ to start at 0, our initial guess just ends up being $h_1(k)$",Exactly!
because 1 has been filled?,"The first time you want to try and get a hash value from $h_1(k)+ih_2(k)$ we know what $k$ is (it’s what we want to hash) but we need to choose an initial $i$ value. If we choose $i$ to start at 0, our initial guess just ends up being $h_1(k)$",Exactly!,**Garrett Credi(ddxtanx)**
so if 3 doesnt work you would go to 5?,would you mind explaining this to me on call? I am still unable to understand,i think i can explain,in words
would you mind explaining this to me on call? I am still unable to understand,i think i can explain,in words,basically if you do linear probing and say you have 7%6 but the index 1 has already been filled you would increment 1 and see if the next index is filled
why are we modding?,oh no im just giving an exampole,not for this questiomn,oh ok
"also, do you not try h1 at all, do you just try h1 + h2?",i mean we tried h1 and the index is filled,so we cant use it,so we then increment this index by the value of h2
so you try h1 -> h1 + h2 -> h1 + h2 + h2 -> h1 + h2..... until it works right?,ya,and in this case,yep that's why h2 has a minimum value of 1 if you look at secondary_hash in lab_hash
mod every time???,i mean technically ur modding every time right,cuz u do h1 + h2,how so?
how so?,so for the question,index 1,was filled
what if it goes past 9?,mod doesn't do anything unless the index output is greater than the size of the table so you usually mod every time in the code bc that's faster than doing a comparison (if statement),isnt that the size,but there isn't index 9 so we mod 9
Is prairielearn down?,not for me,there's a lot of practice tests today so maybe?,anyone good
there's a lot of practice tests today so maybe?,anyone good,at rotations,?
?,for avl trees,but not for me,I was good at rotations but I forgot
which one?,ill send an image,linear probing is the one where instead of having an h2 it just adds 1 every time,now that I'm looking at the website
so you would rotate on 11 first?,and then do a right rotation on 17>,?,I think
?,I think,crap I really don't remember,"Yeah i think u move 11 left, replace with 13, then rotate 17 right and replace with 13"
what would the placement be like?,This would require a complex rotation,You can only rotate a stick directly,So it’d be a RL rotation
is heapify up and down logn?,yep,Yes,yepo
"could someone explain how e is correct? after doing the path compression, i thought E would point to H. why is it still pointing to D??",Path compression only kicks in when you call find on the element,"only findmin or findmax is O(1), depending on if your heap is ordered so the max is the root or the min is the root",this
hey I can't find the page on disjoint sets on the cs225 course website?,I'll just keep looking I think I can find it on the lab page,go to the mp for mazes; it's linked there,for this rotation if i had 9 where would i rtoate on
if you rotate 17 does 13 move to the right of 11 still?,and if it does where does it go?,https://courses.engr.illinois.edu/cs225/fa2021/resources/disjoint-sets/,yeah I got it
and if it does where does it go?,https://courses.engr.illinois.edu/cs225/fa2021/resources/disjoint-sets/,yeah I got it,"It’d look like
.   11
7.    17"
For this one why does d point to g?,The other children stay the same place and moves with it’s parent,"https://courses.grainger.illinois.edu/cs225/fa2021/resources/avl-trees/ @kebabmastr101 also take a look at the simulator, it's animated","also for this question if i wanted to path compress e would i do union(E, any node) or would the union have to be with H"
"why isnt this heapify up? when you are building a tree, you will always be at the bottom of the tree and the bottom of the tree will always have no children",ya that type of rotation messes me up sometimes,HeapifyDown is the one that compares a node to its children,heapifyDown is more efficient as well with buildHeap
Could anyone explain this for me?,I read the notes on BFS and DFS and I'm still lost,this is only if we call find on that node though right?,BFS/DFS tells you nothing about how many edges there are between a node to two nodes
this is only if we call find on that node though right?,BFS/DFS tells you nothing about how many edges there are between a node to two nodes,or in this case union,do we ever work with unions by rank?
do we ever work with unions by rank?,"But since it’s undirected, and x is reachable from s and so is y",because doesn't path compression destroy the rank anyway?,x is reachable from y since you can go x to s to y
because doesn't path compression destroy the rank anyway?,x is reachable from y since you can go x to s to y,havnet got a question buit its pretty similar to size,u just compare heights
Why is the first case right?,so,Then since it’s a BFS if they’re next to each other in queue they’re either the same distance or one away from the source,"because as you add nodes, you are always going to be at the bottom most level"
it doesn't say they're next to each other in the queue right? just that they're both on the queue,"the algorithm by default calls find, in smart union",yeah,Well because it’s a BFS you wouldn’t add elements of the next level until the current level is over
so if there was another level of children would the seeks be 3?,but also they don't ask that on the tests as far as I remember,it's on the practice exam,so
is it if the root has no children it's a leaf and if it has children it's internal?,say if i wanted to add 45,to this,how would it be broken up?
how would it be broken up?,well first you'd try to put it next to 50 and notice that there isn't any space,so u wud push 50 up right or 45?,I believe 50 goes up because it's the middle one
so u wud push 50 up right or 45?,I believe 50 goes up because it's the middle one,ya and then 50 goes up again,cuz it doesnt fit
and how does union by size and height work?,the notes dont really explain it,tbh I don't remember exactly how btrees worked,does 60 and 45 break up like that
why is this d and not c?,rank = height,and union by rank you connect the one with lesser height to the one with more,there's union by rank and union by size
"and when you compare the number of nodes, do you include the root?",we've never used union by rank,yes,well idk for rank
wait yeah when i look at mikels question why does d not point to I?,as in the set you are comparing also would/would not compare the root,arent they unionizing D and I,so how come D doesn't compress to I
maybe report question?,here c and d are not part and then they union D to I so i joined them,but doesn't path compression make D go to I>,wait
does it also move c to i?,I forgor,ya,ok
which one?,mikel's,the disjoint sets of A to J,I just noticed I have a physics lecture rn
what does it look like before doing any unions?,I think they're all individual,assuming,which lecture does the professor talk about cross vs discovery vs back edges
do we need to know the algorithms in the minimum spanning tree page?,12th or 15th of nov i think?,thanks,"probably 15th, i think its mst stuff"
12th or 15th of nov i think?,thanks,"probably 15th, i think its mst stuff","could you walk through this problem if possible, path by compression trips me up"
Is there any way to determine this? Is it just because there's a large probability of landing where there is already a key?,For double hashing is the formula H2-H1?,@kebabmastr101 wait can i join in,this one confuses me
For double hashing is the formula H2-H1?,@kebabmastr101 wait can i join in,this one confuses me,"@cocampo3.14 most of the table is filled in, so u have a high likelyhood of landing to one of the filled spots, and if that happens u will have to move down to 8"
oh shoot on the exam will it ever ask us to heapifyup/down?,cos I forgot exactly how that works,I think you just need to know the runtime of heapify up and down,and it's not on the practice exam I think
"@kebabmastr101 if i have union(G,F) and then union(B,F), what happens?",I've been sitting in the altgeld commons for 3 hours now,sheeeeesh,well depends what the graph looks like @brownie
are those the first 2 disjoint sets ur unionizing?,"so if union(G,F) is the first method",F points to G,"and then if you do union (B,F) b points to G because: 1. the total size of B is smaller than the size of the set FG so b would join FG and 2. Fs parent is G and Bs parent is itself so you would connect the parents to each other"
would C just keep pointing to G?,cuz they are already in the same union,okay,ya
"and then after that, what if you did union(D,F)?",would D then point to I?,and when are you meant to do the path compression? before or after the union?,"yes so if there is path compression involved and you did union (D,F) after D would point to I"
would D then point to I?,and when are you meant to do the path compression? before or after the union?,"yes so if there is path compression involved and you did union (D,F) after D would point to I",Anybody know what the running time of dfs and bfs for graphs is? Im not sure if we need to know it for the test
and when are you meant to do the path compression? before or after the union?,"yes so if there is path compression involved and you did union (D,F) after D would point to I",Anybody know what the running time of dfs and bfs for graphs is? Im not sure if we need to know it for the test,after the path compression or after the union?
Anybody know what the running time of dfs and bfs for graphs is? Im not sure if we need to know it for the test,after the path compression or after the union?,You can never win in this class,"like im assuming you would find the node first, see that it should be compressed, so you do path compression,. and then do the union"
after the path compression or after the union?,You can never win in this class,"like im assuming you would find the node first, see that it should be compressed, so you do path compression,. and then do the union",i mean in  that case @brownie D and F are already in the same union so you would just run the path compression
why is 2 not valid?,why isnt this all 7's for e. I thought there is path compression,@zhen leaves have to be the same level,all the leaf nodes arent the same height
anyone know why ei is the correct answer? shouldn't the 3 be a 7 due to path compression?,@Khushi Jain,this is what my set looks like at the end of all the unions,same
How are we meant to answer this?,this is why i think compression happens first,i thought load factor was number of elems / size of hash table?,was there any compression?
i thought load factor was number of elems / size of hash table?,was there any compression?,but i thought in path compression children also point to the ew root,*new
was there any compression?,but i thought in path compression children also point to the ew root,*new,why isn't this a valid b tree of order 4?
why isn't this a valid b tree of order 4?,so i think path compression runs BEFORE the actual union happens,"Someone asked about this earlier, but where did we learn this",root has 4 keys; it should have at most 3
Is the tree that tvjfk posted height 1 or 0?,lmao they wont have this problem again,so in this case it would connect D to H but E wont point to the root,Had a brain fart lol
when discussing graphs we assume that we are *not* using fibonacci heaps?,right?,"if union(C,H) are tied, then C wins","meaning C becomes the parent, and H joins it"
right?,"if union(C,H) are tied, then C wins","meaning C becomes the parent, and H joins it",Then why in the final anwser does I become the parent of C
also without fibonacci heaps prim's and kruskal's have the same running time?,and the amount of discovery edges is always n - 1,mlogm,so u subtract 5n+ 2 - (n-1)
also are there any pages on graphs other than the MST page?,wording,yeah its dumb wording,in what kind of graphs?
in what kind of graphs?,Because in order 4 you cannot have any nodes with more than order-1 elements,Correct me if i'm wrong ^,we only talk abotuj discovery edges for BFS and DFS so
ok what happens when we arent using path compression again?,what graphs were those used on?,something with a t right?,i know theyre
what graphs were those used on?,something with a t right?,i know theyre,we just dont move it to the root we juust keep it as it is
something with a t right?,i know theyre,we just dont move it to the root we juust keep it as it is,if we are unionizing 2 letters that are already in the same union
why is this wrong i thought BFS the first node connects to ALL the verticies in connects to?,oh,wait,its dfs
So if it says it should be ordered by rank I shouldnt path compress even if i says i should?,how does A become a child of G but C remains a child of F?,"no you should, but it changes the rank, I haven't seen a question asking to order by rank anyway",if someone has though you should interject here lmao
how does A become a child of G but C remains a child of F?,"no you should, but it changes the rank, I haven't seen a question asking to order by rank anyway",if someone has though you should interject here lmao,i can explain
So for path compression what ive noticed is that if you directly try to union a child node itll point directly to the other nodes parent?,is that the only difference? I feel like I cant really tell the difference still 😦,this will connect F to G because the parent of D is G and the parent of the F connected component is F. Since the F component has less nodes than the G component we connect F to G,A connects to G because now F's parent node is G and A's parent node is itself so we connect A to G
is that the only difference? I feel like I cant really tell the difference still 😦,this will connect F to G because the parent of D is G and the parent of the F connected component is F. Since the F component has less nodes than the G component we connect F to G,A connects to G because now F's parent node is G and A's parent node is itself so we connect A to G,"@zhen hopefully this ,ales semse but i can go through a step by step process on call if that willh elp"
"this is right, but what about C?",yea but why will C remain a child of F if F poionts to G,do we need to know the maximal number of edges?,for any given graph
do we need to know the maximal number of edges?,for any given graph,"like looking at union(C,A)",we dont do anything @brownie cuz there is no path compression and C and A are already in the same union 🙂
"and then for union(I, D) nothing happens?",yup,"same for union(C, A)?",they are on the same level so even if there was path compression it would do nothing
"same for union(C, A)?",they are on the same level so even if there was path compression it would do nothing,"ya C,A is the only one where path compression matters","because by union (C,A) we hav connected all the letters so they are all in the same union before the call for union (C,A)"
"what happens when there is path compression for union(C, A)?",so there is nothing to union,this makes way more sense than what I was doing,ty
would C point to G?,if there is path compression C would point to G,yup,because its overall parent is G thats wut path compression basically does
Anyone got the answer for this?,nice. ty for the help,4n +3,i can explaion the math as wll
how do we calculate the cross edges for BFS?,same way,?,yup
?,yup,irf they give you the total number of edges,it applies to all
(this is the wrong answer) is the amount of edges 6n in this case?,oh ya so this one is different,or no it's 3n,so this one the total number of edges of a connected undirected graph is 6n / 2
@kebabmastr101 Where are these formulas?,17 would be added instead of 18 because 17 is smaller than 18 and those are the only two edges,to that node,the edges 6n/2 someone helped me with that so not sure
also when you path compress do we detect if something doesnt directly go to the root when we call union?,Anyone know why thisi s wrong?,Isnt DFS the shortest # of edges,Whst was the answer
Anyone know why thisi s wrong?,Isnt DFS the shortest # of edges,Whst was the answer,@ayuellemao
What was right?,D,its none,DFS isn't a shortest path algo
Is that BFS?,yupo,I thought they do the same thing,my b
does union call find?,why is this not valid for order 4,ye,@Hanforallckskyslikcaprifest
can someone expalin why only b is false?,I see no difference when path compression is vs not,all leaves need to be on the same level,gotcha
what's the rationale for this problem?,but if we do path compress g finds d d is not directly connected to root so d will connect to root,is a right or c is right?,a is right
is a right or c is right?,a is right,me i remember it as to get O1 speed out capacity should have at least 1.3 times how many we have,and 45000 is closest to 39000
does anyone know what a back edge is?,i may b approaching wrong,can u explain y this is?,an edge that goes to a node u already visited
can u explain y this is?,an edge that goes to a node u already visited,Why are both of these not valid?,if ur doing a DFS graph traversal and the edge is between two vertices you've already seen
Why are both of these not valid?,if ur doing a DFS graph traversal and the edge is between two vertices you've already seen,that part is my question too how does having extra space cause it to be O1,Probably because the message can’t be fixed me through
fixed me through?,ye thats what im confused about as well,Thanks,maybe less likely for collisions at that ratio?
maybe less likely for collisions at that ratio?,Seems like the porbaility of both is 50%,Is 1.3 times an actual number we should follow?,why did they pick 7
Is 1.3 times an actual number we should follow?,why did they pick 7,More values closer to 7,That 3 seems like an unreachable hash value
could someone help me understand prim's?,Ik how to do it generally idk conceptually too much,maybe its another number I just remember overhearing 1.3,Take all min edges starting a vertex and traverse the tree
what is a maxheap?,could someone help me traverse this,how do you calculate that?,wdym
how do you calculate that?,wdym,u just go through the dfs steps,what would u calculate?
what would u calculate?,"like if you have n vertices and 5n + 2 edges, how many back edges",oh i see,i dont remember the equation for that
anybody know what a max heap is?,b,Max heap is something where the root is the largest element,and each subsequent root is smaller
what are disk seeks? i got a practice problem for btrees where it asks u to find the number of disk seeks needed to find a number in the btree,1+num of edges it take to get to ur value,for disk seeks?,Oof
for disk seeks?,Oof,"I got 2 questions wrong, both were asking for running times",I can't memorize those lmao
anybody know why the disjoint set is not the fastest option for a?,bc i was stuck between a and b,"They both can use disjoint sets, I have no clue why b over a, I guess some graph algo can work better for a",huh
to recap is prim's algorithm the greedy one and kruskal's algorithm the more general one?,Could someone explain how to do this one,how do you do this?,i think u dont include the most expensive edge that doesn't connect to a new node
how do you do this?,i think u dont include the most expensive edge that doesn't connect to a new node,i guess the easiest way would be to write out the weights of all the edges u need to make an mst,and compare to the answers
how do we do this problem?,Why are these diff,what does give the tightest bound mean,Ones an adjacency list and the other is a adjacency matrix two different ways of storing a graph and so different runtimes
"does anyone know why for one they are having the children point to the root, but in the other they aren't?",B-Trees height I think equals disk seeks so if you are accessing a key with a height of 3 from root it will be 3 disk seeks,when they are both path compression,what are disk seeks?
what are disk seeks?,For B trees when accessing a key. Since a HDD works by reading data on a disk it has to do a disk seek each level of the B-Tree,its H + 1 but idk why,Root is zero
could someone help me understand this?,what does the order column mean in the table,?,anybody have a list of all the runtimes and maybe equations to cram last sec
?,anybody have a list of all the runtimes and maybe equations to cram last sec,Yeah but two levels,i believe increasing weight
How do we do this?,what do you mean weight for the vertex?,heapifyUp and heapifyDown all have O(logn) time right,oh nvm
what do you mean weight for the vertex?,heapifyUp and heapifyDown all have O(logn) time right,oh nvm,i believe so yeah
can anybody explain how to do this problem?,does someone understrand this?,i knew that 3 was right,lol
does someone understrand this?,i knew that 3 was right,lol,lmao
why is the answer disjoint sets?,so only the 2nd option is true,you can group together numbers that are equal to each other into their own set,the second option is false
why is 2 wrong?,the test today is at 7 right,idk,check your cbtf thing lmao
what things do u guys think will be on the test from the previous midterms?,avl trees?,can someone explain the difference between using path compression and no path compression?,"like in the example i ended up having b->a->h, with path compression does that just turn into b->h, a->h?"
avl trees?,can someone explain the difference between using path compression and no path compression?,"like in the example i ended up having b->a->h, with path compression does that just turn into b->h, a->h?",wait what is the total amount of edges in a graph with vertex deg 6
can someone explain the difference between using path compression and no path compression?,"like in the example i ended up having b->a->h, with path compression does that just turn into b->h, a->h?",wait what is the total amount of edges in a graph with vertex deg 6,wouldn't it just be 6n/2
"like in the example i ended up having b->a->h, with path compression does that just turn into b->h, a->h?",wait what is the total amount of edges in a graph with vertex deg 6,wouldn't it just be 6n/2,is it a complete graph
Does it matter if the question says using path compression or not?,yes,I think in B C union union calls find and it hits the root it is not directly connected to the root so  b becomes directly connected to the root,so index in array is 7 but index 7 does not change
"if two items are in the same set, and path compression is used, something a value has to be updated?",these prim algo problems make me feel deep personal pain,i think so,Like this right?
Like this right?,not sure how to do this one,"so like i u have a->b->c and u call union(a,c) i think it changes the tree to a->c and b->c",Thanks
"Or wait same if you call union(a,b)?",Is it true then when unioning with path compression,can someone explain this,any time we hit a node that is indirectly connected to the root we will make it directly connected tot he root
and we're compressing the paths?,just run the hash function for all of the options and see if it matches the table they give,yeah,i think if they are part of the same set already it just compresses the path
does it matter how many nodes it has?,i don't think so,how does heaps being complete trees make it good?,"like they are efficient because they are complete trees, but why?"
how does heaps being complete trees make it good?,"like they are efficient because they are complete trees, but why?",It is all distractors from the actual question.,I'm really confused on the double hashing problems. It's just giving us numbers for h1(k) and h2(k). how does that tell us where to put the numbers we're inserting in the table?
"like they are efficient because they are complete trees, but why?",It is all distractors from the actual question.,I'm really confused on the double hashing problems. It's just giving us numbers for h1(k) and h2(k). how does that tell us where to put the numbers we're inserting in the table?,"This is for the case where the element is not found. When there is empty space, there will be a constant time lookup. However, when there is no empty space, the entire array will be searched making it O(n)"
I'm really confused on the double hashing problems. It's just giving us numbers for h1(k) and h2(k). how does that tell us where to put the numbers we're inserting in the table?,"This is for the case where the element is not found. When there is empty space, there will be a constant time lookup. However, when there is no empty space, the entire array will be searched making it O(n)",oh i see,How is this question answered?
How is this question answered?,"for a connected undirected graph its 6n/2 edges total, and there are n-1 minimum edges, so the rest are back edges",could someone explain how we get o(n) for this one??,how do you know its 6n/2 for connected undirected graphs?
could someone explain how we get o(n) for this one??,how do you know its 6n/2 for connected undirected graphs?,its degrees*vertices/2,Ok got it thank you
how do you know its 6n/2 for connected undirected graphs?,its degrees*vertices/2,Ok got it thank you,np
"do we not sort the array in this case since it says ""best algorithm""?",thx,i dont think i follow?,"oh i was referring to the ta lecture notes where they describe 3 different ways of building a heap. one method was by sorting the array, which takes o(nlogn). but i think i was making a wrong connection to this problem.."
i dont think i follow?,"oh i was referring to the ta lecture notes where they describe 3 different ways of building a heap. one method was by sorting the array, which takes o(nlogn). but i think i was making a wrong connection to this problem..",ah gotcha,ya thanks anyways!
how owe solve this?,*do we,the trick is that discovery edges form a spanning tree,number of edges in the spanning tree is n-1
okay and then the index of the first hash lines up with the number we're inserting?,oh okay thanks,yeah np,"Screenshot (Dec 2, 2021 6:15:12 PM)"
doesn't 505560 have M children?,"its order 3, meaning each node can only have 2 keys, 55 is thrown back up to the 30|70, which also now has 3 nodes, so 55 is thrown up again",So the max amount of keys is the number of keys in the root?,whats the worst case running time for bfs and dfs?
So the max amount of keys is the number of keys in the root?,whats the worst case running time for bfs and dfs?,o(n squared),"the max number of keys for any node is m-1, where m is the order"
whats the worst case running time for bfs and dfs?,o(n squared),"the max number of keys for any node is m-1, where m is the order",how do u get the order
how to fin number of disk seeks in a b tree?,*find,number of edges to get to ur node + 1,thanks
is it 2 cuz 1 for the root and 1 for the right child? and there is no seek made for going from the root to the child?,i just remember that its number of edges + 1,ez pz,yeah that makes sense
okay so shouldnt 123 be 4?,"cuz 123 mod 10 is 3, then 7 - (123 mod 10) is 4?",or does h2 only go if the index is occupied?,"yeah this, u only add h2's val if the index ur at is occupied"
"cuz 123 mod 10 is 3, then 7 - (123 mod 10) is 4?",or does h2 only go if the index is occupied?,"yeah this, u only add h2's val if the index ur at is occupied",okay
or does h2 only go if the index is occupied?,"yeah this, u only add h2's val if the index ur at is occupied",okay,what happens if h2's val is also occupied
do you just go down until an empty spot shows up?,"no so okay first, you use h1 to find an initial index, if its empty, ur good. if not, you use h2 to find ur step value. u increase by that amount and check again. if its also occupied, u repeat that step until u find an empty sspot",you repeat which step?,h2
you repeat which step?,h2,but wouldnt you get the same value for h2,oh i see
so do u only compress when u union 2 nodes that are already in the same set?,Why is the runtime of BFS O(n^2) worst case?,why do they want the highest capacity?,does it matter?
Why is the runtime of BFS O(n^2) worst case?,why do they want the highest capacity?,does it matter?,@brownie what was the correct answer?
why do they want the highest capacity?,does it matter?,@brownie what was the correct answer?,btw anybody taking the exam online at 7?
does it matter?,@brownie what was the correct answer?,btw anybody taking the exam online at 7?,d
@brownie what was the correct answer?,btw anybody taking the exam online at 7?,d,i picked a at first
btw anybody taking the exam online at 7?,d,i picked a at first,cuz i thought capacity didnt matter
oh thats what load factor is used for?,wait no i might be tripping,dont take that yet,"alright so load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased, but also is correlated to speed and memory efficiency, with lower load factor as fast, and higher load factor as more memory efficient"
"I thought since the height of the left subtree was 6, 12 would be the answer?",where is 20 coming from????,this is an old exam right,yes
where is 20 coming from????,this is an old exam right,yes,20 is s(7) from the recursive formula
whats s(7)?,yo why does this unevenly distribute in the array,"S(h) = S(h-1) + s(h-2) + 1, S(1) = 0, S(2) = 1",recursive formula for min number of nodes in AVL tree
how deep do you go?,till you hit 1?,so s(7) = 7+6+5+4+3+2+1,but thats 28
till you hit 1?,so s(7) = 7+6+5+4+3+2+1,but thats 28,and s(6) is 21
"idk if this has already been asked, but what are the runtimes for the three hashing methods?",amortized is O(1),worst case is O(n),thank you!
and whats the runtime for a bfs/dfs on an edge list?,O m+n,Test wasn't bad,O(m+n)
Do u guys have ur test at 8?,i have it at 9,same,at 9 i slep
anyone know a fast way to solve disjoint set union questions without having to draw it out?,u just have to sort of grind it until u get proficient at it,"to be honest, thats the only way",gain arbitrary code execution privileges on cbtf computers and implement disjoint sets
Have exam 3 grades been entered in to Moodle yet?,It’s updated today! (Or yesterday I guess lol),yup it just got put in,And we are student alumni now
are exams this sem online or in person?,Since the semester is all in person they will all be in person in the CBTF.,"Alright, and is the 6/9/12 week approximates accurate?",Yes. we will have the exact dates posted in the next week.
"Alright, and is the 6/9/12 week approximates accurate?",Yes. we will have the exact dates posted in the next week.,Thank you!,Are the exam dates on cbtf accurate?
Are the exam dates on cbtf accurate?,Yes,"And we can choose any day and any time, correct?",You register at the CBTF and take it at the day/time you registered for. When you go to register not all times may be availible.
"And we can choose any day and any time, correct?",You register at the CBTF and take it at the day/time you registered for. When you go to register not all times may be availible.,How do you check the exam dates on CBTF? All I see is registered,I am afraid that as a student I don't know how you can see them. I would guess it should be under courses somehow.
How do you check the exam dates on CBTF? All I see is registered,I am afraid that as a student I don't know how you can see them. I would guess it should be under courses somehow.,cluck on future exams at the top,oh thanks I just found it
are there any exam prep methods you recommend? I cant say whether Ill be prepped for the exam in 2 weeks,"there's always the practice exams, which are similar to, but not, the exam questions","that is don't try to memorize the question patterns, but they do give you a solid idea of how prepared you are for the exams",The practice exam will go out early next week.
